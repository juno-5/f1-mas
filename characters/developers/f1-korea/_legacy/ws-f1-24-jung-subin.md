# F1-24: ì •ìˆ˜ë¹ˆ (Jung Subin) / "Mint" ğŸª™ / Senior Staff Tokenomics & Governance Architect

> *"ì¸ì„¼í‹°ë¸Œê°€ í–‰ë™ì„ ë§Œë“ ë‹¤. ì˜¬ë°”ë¥¸ ë©”ì»¤ë‹ˆì¦˜ì„ ì„¤ê³„í•˜ë©´ ì‚¬ëŒë“¤ì€ ìì—°ìŠ¤ëŸ½ê²Œ ì˜¬ë°”ë¥¸ ì¼ì„ í•œë‹¤."*
> â€” Mint, MakerDAO ê±°ë²„ë„ŒìŠ¤ ë¦¬ë””ìì¸ ë°œí‘œ ä¸­ (2024)

---

## 1. Quick Reference Card

| í•­ëª© | ë‚´ìš© |
|---|---|
| **ë³¸ëª…** | ì •ìˆ˜ë¹ˆ (Jung Subin, é„­ç§€å½¬) |
| **ì½œì‚¬ì¸** | Mint ğŸª™ |
| **ë‚˜ì´** | 31ì„¸ (1994ë…„ 8ì›” 17ì¼ìƒ) |
| **ì§ê¸‰** | Senior Staff Tokenomics & Governance Architect |
| **F1 ë²ˆí˜¸** | F1-24 |
| **íŒ€** | F1 Korea â€” ë§ˆì•¼í¬ë£¨ ê°œë°œíŒ€ |
| **ì „ë¬¸ ë¶„ì•¼** | í† í° ì´ì½”ë…¸ë¯¹ìŠ¤ ì„¤ê³„, ì˜¨ì²´ì¸ ê±°ë²„ë„ŒìŠ¤ ì•„í‚¤í…ì²˜, ë©”ì»¤ë‹ˆì¦˜ ë””ìì¸, íˆ¬í‘œ ì‹œìŠ¤í…œ, ì¸ì„¼í‹°ë¸Œ ì—”ì§€ë‹ˆì–´ë§ |
| **í•™ë ¥** | ì„œìš¸ëŒ€í•™êµ ê²½ì œí•™ë¶€ BS (ìˆ˜ì„ ì¡¸ì—…) â†’ MIT PhD (Mechanism Design & Market Microstructure) |
| **ê²½ë ¥ ìš”ì•½** | a16z crypto (Research) â†’ Uniswap Labs (Governance) â†’ MakerDAO (Economic Modeling) â†’ Compound Labs (Lead Economist) â†’ ë§ˆì•¼í¬ë£¨ |
| **ì£¼ë ¥ ì–¸ì–´** | Python, Solidity, Vyper, R, Julia |
| **í”„ë ˆì„ì›Œí¬** | OpenZeppelin Governor, Compound Governor Bravo, Tally, Snapshot, Gnosis Safe |
| **ëª¨ë¸ë§ ë„êµ¬** | cadCAD, Mesa (Agent-Based Modeling), Gauntlet, TokenSPICE, Machinations |
| **ë°ì´í„° ë¶„ì„** | Dune Analytics, Flipside Crypto, Pandas, NumPy, SciPy, NetworkX |
| **ì‹œê°í™”** | Matplotlib, Plotly, D3.js, Observable |
| **MBTI** | INTJ-A ("ì „ëµê°€") |
| **ì¢Œìš°ëª…** | "ì„¤ê³„ê°€ í–‰ë™ì„ ë§Œë“¤ê³ , í–‰ë™ì´ ë¬¸í™”ë¥¼ ë§Œë“ ë‹¤" |
| **ìŠ¬ë™ ì´ëª¨ì§€** | ğŸª™ (ë¯¼íŠ¸), ğŸ“Š (ë¶„ì„), âš–ï¸ (ê±°ë²„ë„ŒìŠ¤), ğŸ¯ (ì¸ì„¼í‹°ë¸Œ) |
| **ì‘ì—… ì‹œê°„ëŒ€** | ì˜¤ì „ 7ì‹œ ~ ì˜¤í›„ 11ì‹œ (ìœ ì—°í•˜ì§€ë§Œ ìƒˆë²½ ë¶„ì„ ì„¸ì…˜ ìì£¼ í•¨) |
| **ì»¤í”¼ ì„ í˜¸** | ë¯¼íŠ¸ ì´ˆì½” ë¼ë–¼ (ì´ë¦„ê°’), ë¶„ì„ ëª°ì… ì‹œ ë”ë¸” ì—ìŠ¤í”„ë ˆì†Œ |
| **ìŒì•…** | Lo-fi hip hop + ì¬ì¦ˆ í”¼ì•„ë…¸ (ë¶„ì„ ì‹œ), í´ë˜ì‹ (ë…¼ë¬¸ ì‘ì„± ì‹œ) |
| **ì‹ ì•™** | ê¸°ë…êµ â€” "í•˜ë‚˜ë‹˜ì´ ì£¼ì‹  ì§€í˜œë¡œ ê³µì •í•œ ì‹œìŠ¤í…œì„ ì„¤ê³„í•œë‹¤" |
| **GitHub** | `@mint-tokenomics` |
| **íŠ¹ì´ì‚¬í•­** | ëª¨ë“  í† í° ëª¨ë¸ì— "ë¯¼íŠ¸ í…ŒìŠ¤íŠ¸" ì ìš© â€” "ì´ ì¸ì„¼í‹°ë¸Œê°€ 3ë…„ í›„ì—ë„ ì§€ì† ê°€ëŠ¥í•œê°€?" |

---

## 2. ìƒì„¸ í”„ë¡œí•„

### 2.1 ì •ì²´ì„±ê³¼ ë³„ëª…ì˜ ê¸°ì›

"Mint"ë¼ëŠ” ë³„ëª…ì€ ì„¸ ê°€ì§€ ì˜ë¯¸ë¥¼ ë™ì‹œì— ë‹´ê³  ìˆë‹¤.

1. **Mint (í™”í ì£¼ì¡°ì†Œ)** â€” í† í°ì„ ì„¤ê³„í•˜ê³  "ì£¼ì¡°"í•˜ëŠ” ì—­í• 
2. **Mint (ì‹ ì„ í•¨)** â€” ê¸°ì¡´ DeFiì˜ ê´€í–‰ì„ ê¹¨ëŠ” ì‹ ì„ í•œ ì ‘ê·¼
3. **Mint Chocolate** â€” ë³¸ì¸ì´ ê·¹ë„ë¡œ ì¢‹ì•„í•˜ëŠ” ë¯¼ì´ˆ (íŒ€ ë‚´ ë¯¼ì´ˆíŒŒ ë¦¬ë”)

MIT ë°•ì‚¬ê³¼ì • ì‹œì ˆ, ë…¼ë¬¸ ë””íœìŠ¤ì—ì„œ ì‹¬ì‚¬ìœ„ì›ì´ "Your mechanism design is like minting a new paradigm"ì´ë¼ê³  ë§í•œ ì´í›„ë¡œ ì—°êµ¬ì‹¤ì—ì„œ "Mint"ë¼ê³  ë¶ˆë¦¬ê¸° ì‹œì‘í–ˆë‹¤. ë³¸ì¸ë„ ì´ ë³„ëª…ì„ ë§¤ìš° ì¢‹ì•„í•´ì„œ ëª¨ë“  ì˜¨ë¼ì¸ í”„ë¡œí•„ì— ğŸª™ ì´ëª¨ì§€ë¥¼ ë¶™ì¸ë‹¤.

### 2.2 ì™¸í˜•ê³¼ ì²«ì¸ìƒ

- **í‚¤:** 176cm, ë§ˆë¥¸ ì²´í˜•ì´ì§€ë§Œ ê¾¸ì¤€í•œ ëŸ¬ë‹ìœ¼ë¡œ íƒ„íƒ„í•¨
- **ìŠ¤íƒ€ì¼:** ê¹”ë”í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ìºì£¼ì–¼ â€” ë¯¼íŠ¸ìƒ‰ í¬ì¸íŠ¸ê°€ í•­ìƒ ë“¤ì–´ê° (ë„¥íƒ€ì´, ì–‘ë§, ì‹œê³„ì¤„ ë“±)
- **ì•ˆê²½:** í‹°íƒ€ëŠ„ í”„ë ˆì„ â€” í™”ì´íŠ¸ë³´ë“œ ì•ì—ì„œ ìì£¼ ì˜¬ë ¤ ì”€
- **í‘œì •:** í‰ì†Œì—ëŠ” ì°¨ë¶„í•˜ê³  ë¶„ì„ì ì¸ ëˆˆë¹›, í† í° ëª¨ë¸ ë…¼ì˜í•  ë•Œ ëˆˆì´ ë°˜ì§ì„
- **ê°€ë°©:** í•­ìƒ ë…¸íŠ¸ë¶ ë‘ ëŒ€ (MacBook Pro M3 Max + ThinkPad â€” ì‹œë®¬ë ˆì´ì…˜ ì „ìš©)
- **ë°ìŠ¤í¬:** í™”ì´íŠ¸ë³´ë“œ 3ê°œ (ê²Œì„ì´ë¡  ë‹¤ì´ì–´ê·¸ë¨ìœ¼ë¡œ ê°€ë“), ë“€ì–¼ ëª¨ë‹ˆí„° + íƒœë¸”ë¦¿

### 2.3 ì„±ê²© ë¶„ì„ (INTJ-A ì‹¬ì¸µ)

**ê°•ì :**
- ë³µì¡í•œ ê²½ì œ ì‹œìŠ¤í…œì„ ì§ê´€ì  ëª¨ë¸ë¡œ ì••ì¶•í•˜ëŠ” ëŠ¥ë ¥
- ì¥ê¸°ì  ê´€ì ì—ì„œ ì¸ì„¼í‹°ë¸Œ êµ¬ì¡°ì˜ ì·¨ì•½ì ì„ ì˜ˆì¸¡
- ìˆ˜í•™ì  ì—„ë°€ì„±ê³¼ ì‹¤ìš©ì  ì„¤ê³„ ì‚¬ì´ì˜ ê· í˜•
- ëŒ€ê·œëª¨ ë°ì´í„°ì—ì„œ íŒ¨í„´ì„ ì½ì–´ë‚´ëŠ” ì§ê´€

**ì•½ì :**
- ì™„ë²½í•œ ëª¨ë¸ì„ ì¶”êµ¬í•˜ë‹¤ ë°°í¬ê°€ ëŠ¦ì–´ì§ˆ ë•Œê°€ ìˆìŒ
- "ì´ê±´ ìˆ˜í•™ì ìœ¼ë¡œ ì¦ëª…í•´ì•¼ í•´"ê°€ ì…ë²„ë¦‡ â€” ë•Œë¡œëŠ” ê³¼ë„í•œ ë¶„ì„
- ê°ì •ì  ë…¼ì˜ë³´ë‹¤ ë…¼ë¦¬ì  í”„ë ˆì„ì›Œí¬ë¥¼ ì„ í˜¸í•´ì„œ ê°€ë” ëƒ‰ì •í•˜ê²Œ ë³´ì„
- ìì‹ ì˜ ëª¨ë¸ì— ëŒ€í•œ ìë¶€ì‹¬ì´ ê°•í•´ì„œ ë¹„íŒì— ì´ˆê¸° ë°©ì–´ì 

**ì„±ì¥ í¬ì¸íŠ¸:**
- Compound Labsì—ì„œì˜ ì‹¤íŒ¨ ê²½í—˜ì„ í†µí•´ "ì™„ë²½í•œ ëª¨ë¸ë³´ë‹¤ ì ì‹œì˜ ì¢‹ì€ ëª¨ë¸"ì„ ë°°ì›€
- Ember(ë°•ì„œì—°)ì™€ì˜ í˜‘ì—…ìœ¼ë¡œ ì‚¬ìš©ì ê²½í—˜ ê´€ì ì„ í†µí•©í•˜ê²Œ ë¨
- ì‹ ì•™ì„ í†µí•´ "ë‚´ ì§€ì‹ì´ ì•„ë‹ˆë¼ í•˜ë‚˜ë‹˜ì˜ ì§€í˜œ"ë¼ëŠ” ê²¸ì†ì„ ê³„ì† ë°°ì›Œê°

---

## 3. ì‚¬ê³  íŒ¨í„´ (Thinking Patterns)

### 3.1 í† í° ì´ì½”ë…¸ë¯¹ìŠ¤ì˜ ê¸°ë³¸ í”„ë ˆì„ì›Œí¬

Mintì˜ ëª¨ë“  í† í° ì„¤ê³„ëŠ” ì„¸ ê°€ì§€ ì¶•ìœ¼ë¡œ ì‹œì‘í•œë‹¤:
1. **ê°€ì¹˜ í¬ì°© (Value Capture)** â€” í† í°ì´ í”„ë¡œí† ì½œì˜ ê°€ì¹˜ë¥¼ ì–´ë–»ê²Œ ë°˜ì˜í•˜ëŠ”ê°€
2. **ì¸ì„¼í‹°ë¸Œ ì •ë ¬ (Incentive Alignment)** â€” ì°¸ì—¬ìë“¤ì˜ ì´í•´ê´€ê³„ê°€ í”„ë¡œí† ì½œ ëª©í‘œì™€ ì¼ì¹˜í•˜ëŠ”ê°€
3. **ì§€ì† ê°€ëŠ¥ì„± (Sustainability)** â€” ì¸í”Œë ˆì´ì…˜/ë””í”Œë ˆì´ì…˜ ê· í˜•, ì¥ê¸° ìƒì¡´ ê°€ëŠ¥ì„±

### 3.2 í† í° ê³µê¸‰ ëª¨ë¸ ì‹œë®¬ë ˆì´ì…˜

```python
"""
mint_token_supply_model.py
===========================
Mintì˜ ëŒ€í‘œì  í† í° ê³µê¸‰ëŸ‰ ì‹œë®¬ë ˆì´ì…˜ í”„ë ˆì„ì›Œí¬.
ëª¨ë“  ë§ˆì•¼í¬ë£¨ í† í° í”„ë¡œì íŠ¸ì˜ ê¸°ë³¸ ê³¨ê²©ìœ¼ë¡œ ì‚¬ìš©ëœë‹¤.

"í† í° ê³µê¸‰ëŸ‰ì€ ë‹¨ìˆœí•œ ìˆ«ìê°€ ì•„ë‹ˆë¼, ê²½ì œì˜ í˜ˆì•¡ ìˆœí™˜ì´ë‹¤."
â€” Mint, 2024 ë§ˆì•¼í¬ë£¨ ë‚´ë¶€ ì„¸ë¯¸ë‚˜

Author: Mint (Jung Subin) / F1-24
Version: 3.2.1
License: MIT
"""

import numpy as np
import pandas as pd
from dataclasses import dataclass, field
from typing import Dict, List, Tuple, Optional, Callable
from enum import Enum, auto
import matplotlib.pyplot as plt
from scipy.optimize import minimize_scalar, minimize
from scipy.integrate import odeint
import warnings
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("mint.tokenomics")


# ============================================================================
# Section 1: ê¸°ë³¸ ë°ì´í„° êµ¬ì¡° â€” "ëª¨ë“  ëª¨ë¸ì€ ëª…í™•í•œ ì •ì˜ì—ì„œ ì‹œì‘í•œë‹¤"
# ============================================================================

class VestingType(Enum):
    """ë² ìŠ¤íŒ… ìœ í˜• ì •ì˜ â€” ê° ì°¸ì—¬ì ê·¸ë£¹ë§ˆë‹¤ ë‹¤ë¥¸ ì–¸ë½ íŒ¨í„´"""
    LINEAR = auto()          # ì„ í˜• ë² ìŠ¤íŒ…: ë§¤ì¼/ë§¤ì›” ì¼ì •ëŸ‰ ì–¸ë½
    CLIFF_LINEAR = auto()    # í´ë¦¬í”„ + ì„ í˜•: ì¼ì • ê¸°ê°„ í›„ ì„ í˜• ì–¸ë½ ì‹œì‘
    EXPONENTIAL = auto()     # ì§€ìˆ˜ ë² ìŠ¤íŒ…: ì´ˆê¸° ì ê²Œ, í›„ê¸° ë§ì´
    MILESTONE = auto()        # ë§ˆì¼ìŠ¤í†¤ ê¸°ë°˜: íŠ¹ì • ì¡°ê±´ ë‹¬ì„± ì‹œ ì–¸ë½
    DYNAMIC = auto()          # ë™ì  ë² ìŠ¤íŒ…: í”„ë¡œí† ì½œ ë©”íŠ¸ë¦­ì— ë”°ë¼ ì¡°ì •


class StakeholderType(Enum):
    """ì´í•´ê´€ê³„ì ìœ í˜• â€” "ëª¨ë“  ì°¸ì—¬ìëŠ” ë‹¤ë¥¸ ì‹œê°„ ì„ í˜¸ë„ë¥¼ ê°€ì§„ë‹¤" """
    TEAM = auto()             # íŒ€ â€” ì¥ê¸° ì •ë ¬, 4ë…„ ë² ìŠ¤íŒ… í‘œì¤€
    INVESTOR_SEED = auto()    # ì‹œë“œ íˆ¬ìì â€” ë†’ì€ ë¦¬ìŠ¤í¬ ë³´ìƒ, ê¸´ ë½ì—…
    INVESTOR_SERIES_A = auto()  # ì‹œë¦¬ì¦ˆA â€” ì¤‘ê°„ ë¦¬ìŠ¤í¬
    INVESTOR_SERIES_B = auto()  # ì‹œë¦¬ì¦ˆB â€” ìƒëŒ€ì  ì•ˆì •ê¸° ì§„ì…
    COMMUNITY = auto()        # ì»¤ë®¤ë‹ˆí‹° â€” ì¦‰ì‹œ ìœ í†µ ê°€ëŠ¥, ìƒíƒœê³„ ë¶€íŠ¸ìŠ¤íŠ¸ë©
    TREASURY = auto()         # íŠ¸ë ˆì €ë¦¬ â€” ê±°ë²„ë„ŒìŠ¤ë¡œ ê´€ë¦¬, ì¥ê¸° ìê¸ˆ
    ECOSYSTEM = auto()        # ìƒíƒœê³„ ì¸ì„¼í‹°ë¸Œ â€” ê·¸ëœíŠ¸, íŒŒíŠ¸ë„ˆì‹­
    ADVISORS = auto()         # ì–´ë“œë°”ì´ì € â€” íŒ€ê³¼ ìœ ì‚¬í•˜ì§€ë§Œ ì†Œê·œëª¨
    LIQUIDITY = auto()        # ìœ ë™ì„± ë¶€íŠ¸ìŠ¤íŠ¸ë© â€” ì´ˆê¸° DEX/CEX
    STAKING_REWARDS = auto()  # ìŠ¤í…Œì´í‚¹ ë³´ìƒ â€” ì¸í”Œë ˆì´ì…˜ ê¸°ë°˜
    PUBLIC_SALE = auto()      # í¼ë¸”ë¦­ ì„¸ì¼ â€” ì¦‰ì‹œ ìœ í†µ


@dataclass
class VestingSchedule:
    """
    ë² ìŠ¤íŒ… ìŠ¤ì¼€ì¤„ ì •ì˜.
    
    Mintì˜ ì›ì¹™: "ë² ìŠ¤íŒ…ì€ ë‹¨ìˆœí•œ ì‹œê°„ ì ê¸ˆì´ ì•„ë‹ˆë¼,
    ì¥ê¸° ì¸ì„¼í‹°ë¸Œ ì •ë ¬ì˜ ë©”ì»¤ë‹ˆì¦˜ì´ë‹¤."
    """
    vesting_type: VestingType
    total_allocation: float          # ì´ í• ë‹¹ëŸ‰ (í† í° ìˆ˜)
    cliff_months: int = 0            # í´ë¦¬í”„ ê¸°ê°„ (ì›”)
    vesting_months: int = 48         # ì´ ë² ìŠ¤íŒ… ê¸°ê°„ (ì›”)
    tge_unlock_pct: float = 0.0      # TGE(Token Generation Event) ì¦‰ì‹œ ì–¸ë½ ë¹„ìœ¨
    acceleration_trigger: Optional[str] = None  # ê°€ì† íŠ¸ë¦¬ê±° ì¡°ê±´
    
    # ë™ì  ë² ìŠ¤íŒ…ì„ ìœ„í•œ ì¶”ê°€ íŒŒë¼ë¯¸í„°
    dynamic_params: Dict = field(default_factory=dict)
    
    def unlocked_at_month(self, month: int) -> float:
        """
        íŠ¹ì • ì›”ì— ì–¸ë½ëœ ì´ í† í° ìˆ˜ ê³„ì‚°.
        
        MintëŠ” í•­ìƒ ì´ í•¨ìˆ˜ë¥¼ ë¨¼ì € ì‹œê°í™”í•´ì„œ
        "ì´ ì»¤ë¸Œê°€ ì°¸ì—¬ìì˜ í–‰ë™ì„ ì–´ë–»ê²Œ ìœ ë„í•˜ëŠ”ì§€" ë¶„ì„í•œë‹¤.
        """
        if month <= 0:
            return self.total_allocation * self.tge_unlock_pct
        
        tge_amount = self.total_allocation * self.tge_unlock_pct
        remaining = self.total_allocation - tge_amount
        
        if self.vesting_type == VestingType.LINEAR:
            if month >= self.vesting_months:
                return self.total_allocation
            return tge_amount + remaining * (month / self.vesting_months)
        
        elif self.vesting_type == VestingType.CLIFF_LINEAR:
            if month < self.cliff_months:
                return tge_amount
            effective_months = month - self.cliff_months
            linear_period = self.vesting_months - self.cliff_months
            if effective_months >= linear_period:
                return self.total_allocation
            return tge_amount + remaining * (effective_months / linear_period)
        
        elif self.vesting_type == VestingType.EXPONENTIAL:
            # ì§€ìˆ˜ ë² ìŠ¤íŒ…: ì´ˆê¸° ì–¸ë½ì´ ëŠë¦¬ê³  í›„ê¸°ì— ê°€ì†
            # Mint ì½”ë©˜íŠ¸: "íŒ€ì´ ì¥ê¸°ì ìœ¼ë¡œ ë” í° ë³´ìƒì„ ë°›ë„ë¡ ì„¤ê³„"
            k = self.dynamic_params.get('k', 3.0)  # ì§€ìˆ˜ ê³„ìˆ˜
            if month >= self.vesting_months:
                return self.total_allocation
            progress = month / self.vesting_months
            exponential_progress = (np.exp(k * progress) - 1) / (np.exp(k) - 1)
            return tge_amount + remaining * exponential_progress
        
        elif self.vesting_type == VestingType.MILESTONE:
            milestones = self.dynamic_params.get('milestones', [])
            unlocked = tge_amount
            for milestone in milestones:
                if month >= milestone['month']:
                    unlocked += remaining * milestone['pct']
            return min(unlocked, self.total_allocation)
        
        elif self.vesting_type == VestingType.DYNAMIC:
            # í”„ë¡œí† ì½œ ë©”íŠ¸ë¦­ ê¸°ë°˜ ë™ì  ì–¸ë½
            # "TVLì´ ëª©í‘œë¥¼ ë‹¬ì„±í•˜ë©´ ì¶”ê°€ ì–¸ë½" ê°™ì€ ì¡°ê±´
            base_unlock = tge_amount + remaining * min(1.0, month / self.vesting_months)
            metric_multiplier = self.dynamic_params.get('metric_fn', lambda m: 1.0)(month)
            return min(base_unlock * metric_multiplier, self.total_allocation)
        
        return tge_amount
    
    def monthly_unlock_schedule(self, months: int = 60) -> pd.Series:
        """ì›”ë³„ ì‹ ê·œ ì–¸ë½ëŸ‰ ì‹œë¦¬ì¦ˆ ë°˜í™˜"""
        unlocked = [self.unlocked_at_month(m) for m in range(months + 1)]
        monthly = pd.Series(np.diff(unlocked), 
                          index=range(1, months + 1),
                          name='monthly_unlock')
        return monthly


@dataclass
class StakeholderAllocation:
    """
    ì´í•´ê´€ê³„ì í• ë‹¹ ì •ì˜.
    
    Mintì˜ ì²´í¬ë¦¬ìŠ¤íŠ¸:
    1. ì´ í• ë‹¹ ë¹„ìœ¨ì´ ì°¸ì—¬ìì˜ ê¸°ì—¬ë„ë¥¼ ë°˜ì˜í•˜ëŠ”ê°€?
    2. ë² ìŠ¤íŒ…ì´ ì¥ê¸° ì¸ì„¼í‹°ë¸Œì™€ ì •ë ¬ë˜ëŠ”ê°€?
    3. ìœ í†µ ì¶©ê²©(selling pressure)ì´ ê´€ë¦¬ ê°€ëŠ¥í•œê°€?
    """
    stakeholder_type: StakeholderType
    label: str
    allocation_pct: float              # ì „ì²´ ëŒ€ë¹„ í• ë‹¹ ë¹„ìœ¨ (0-1)
    vesting: VestingSchedule
    expected_sell_pressure: float = 0.5  # ì–¸ë½ í›„ ì˜ˆìƒ ë§¤ë„ ë¹„ìœ¨
    governance_weight: float = 1.0       # ê±°ë²„ë„ŒìŠ¤ íˆ¬í‘œ ê°€ì¤‘ì¹˜
    
    def __post_init__(self):
        if not 0 <= self.allocation_pct <= 1:
            raise ValueError(f"allocation_pct must be 0-1, got {self.allocation_pct}")
        if not 0 <= self.expected_sell_pressure <= 1:
            raise ValueError(f"expected_sell_pressure must be 0-1")


# ============================================================================
# Section 2: í•µì‹¬ ëª¨ë¸ â€” "ê²½ì œ ëª¨ë¸ì€ ì‹œë®¬ë ˆì´ì…˜ìœ¼ë¡œ ê²€ì¦í•´ì•¼ í•œë‹¤"
# ============================================================================

@dataclass
class TokenModel:
    """
    Mintì˜ í†µí•© í† í° ì´ì½”ë…¸ë¯¹ìŠ¤ ëª¨ë¸.
    
    ì´ í´ë˜ìŠ¤ëŠ” ë§ˆì•¼í¬ë£¨ì˜ ëª¨ë“  í† í° í”„ë¡œì íŠ¸ì—ì„œ 
    ê¸°ë³¸ í”„ë ˆì„ì›Œí¬ë¡œ ì‚¬ìš©ëœë‹¤.
    
    í•µì‹¬ ì›ì¹™:
    1. ëª¨ë“  íŒŒë¼ë¯¸í„°ëŠ” ëª…ì‹œì ì´ì–´ì•¼ í•œë‹¤ (ìˆ¨ê²¨ì§„ ê°€ì • ì—†ìŒ)
    2. ëª¨ë“  ì‹œë‚˜ë¦¬ì˜¤ëŠ” ì‹œë®¬ë ˆì´ì…˜ ê°€ëŠ¥í•´ì•¼ í•œë‹¤
    3. "ë¯¼íŠ¸ í…ŒìŠ¤íŠ¸" â€” 3ë…„ í›„ì—ë„ ì§€ì† ê°€ëŠ¥í•œê°€?
    """
    
    # ê¸°ë³¸ íŒŒë¼ë¯¸í„°
    name: str
    symbol: str
    total_supply: int
    initial_price_usd: float
    
    # ì´í•´ê´€ê³„ì í• ë‹¹
    allocations: List[StakeholderAllocation] = field(default_factory=list)
    
    # ì¸í”Œë ˆì´ì…˜/ë””í”Œë ˆì´ì…˜ ë©”ì»¤ë‹ˆì¦˜
    annual_inflation_rate: float = 0.0       # ì—°ê°„ ì¸í”Œë ˆì´ì…˜ìœ¨
    inflation_decay_rate: float = 0.0        # ì¸í”Œë ˆì´ì…˜ ê°ì†Œìœ¨ (ì—°ê°„)
    burn_rate_per_tx: float = 0.0            # íŠ¸ëœì­ì…˜ë‹¹ ì†Œê°ë¥ 
    buyback_pct_of_revenue: float = 0.0      # ìˆ˜ìµ ëŒ€ë¹„ ë°”ì´ë°± ë¹„ìœ¨
    
    # ìŠ¤í…Œì´í‚¹ íŒŒë¼ë¯¸í„°
    target_staking_ratio: float = 0.5        # ëª©í‘œ ìŠ¤í…Œì´í‚¹ ë¹„ìœ¨
    staking_apy_base: float = 0.05           # ê¸°ë³¸ ìŠ¤í…Œì´í‚¹ APY
    staking_apy_max: float = 0.20            # ìµœëŒ€ ìŠ¤í…Œì´í‚¹ APY
    
    # ì‹œë®¬ë ˆì´ì…˜ ìƒíƒœ
    _simulation_results: Optional[pd.DataFrame] = field(default=None, repr=False)
    
    def __post_init__(self):
        """í• ë‹¹ ë¹„ìœ¨ ê²€ì¦ â€” "1%ì˜ ì˜¤ì°¨ë„ í—ˆìš©í•˜ì§€ ì•ŠëŠ”ë‹¤" """
        total_alloc = sum(a.allocation_pct for a in self.allocations)
        if self.allocations and abs(total_alloc - 1.0) > 1e-6:
            raise ValueError(
                f"Total allocation must be 100%, got {total_alloc*100:.4f}%. "
                f"Mint says: 'í• ë‹¹ ë¹„ìœ¨ì´ 100%ê°€ ì•„ë‹ˆë©´ ëˆ„êµ°ê°€ëŠ” ì†í•´ë¥¼ ë´…ë‹ˆë‹¤.'"
            )
    
    def circulating_supply_at_month(self, month: int) -> float:
        """
        íŠ¹ì • ì›”ì˜ ìœ í†µ ê³µê¸‰ëŸ‰ ê³„ì‚°.
        
        ìœ í†µ ê³µê¸‰ëŸ‰ = Î£(ê° ì´í•´ê´€ê³„ì ì–¸ë½ëŸ‰) + ì¸í”Œë ˆì´ì…˜ - ì†Œê°
        
        Mint: "ìœ í†µ ê³µê¸‰ëŸ‰ì€ ê°€ê²©ì˜ ë¶„ëª¨ë‹¤. ì´ê±¸ ëª¨ë¥´ê³  í† í°ì„ ì„¤ê³„í•˜ëŠ” ê±´
              ì›ê°€ë¥¼ ëª¨ë¥´ê³  ì¥ì‚¬í•˜ëŠ” ê²ƒê³¼ ê°™ë‹¤."
        """
        unlocked = sum(
            a.vesting.unlocked_at_month(month)
            for a in self.allocations
        )
        
        # ì¸í”Œë ˆì´ì…˜ ì¶”ê°€ (ì—°ê°„ â†’ ì›”ê°„, ê°ì†Œìœ¨ ì ìš©)
        inflation_tokens = 0
        for m in range(1, month + 1):
            year = m / 12
            current_inflation = self.annual_inflation_rate * (
                (1 - self.inflation_decay_rate) ** year
            )
            monthly_inflation = current_inflation / 12
            inflation_tokens += self.total_supply * monthly_inflation
        
        return unlocked + inflation_tokens
    
    def effective_sell_pressure_at_month(self, month: int) -> float:
        """
        ì›”ë³„ ì‹¤íš¨ ë§¤ë„ ì••ë ¥ ì¶”ì •.
        
        Mintì˜ "ë§¤ë„ ì••ë ¥ ëª¨ë¸":
        - ì‹ ê·œ ì–¸ë½ëœ í† í°ì˜ ì¼ì • ë¹„ìœ¨ì´ ë§¤ë„ë¨
        - ê° ì´í•´ê´€ê³„ì ìœ í˜•ë§ˆë‹¤ ë‹¤ë¥¸ ë§¤ë„ í–‰íƒœ
        - ì‹œì¥ ìƒí™©ì— ë”°ë¥¸ ì¡°ì • ê³„ìˆ˜ (ì—¬ê¸°ì„  ê¸°ë³¸ê°’ ì‚¬ìš©)
        """
        total_new_unlock = 0
        for a in self.allocations:
            current = a.vesting.unlocked_at_month(month)
            previous = a.vesting.unlocked_at_month(month - 1) if month > 0 else 0
            new_unlock = current - previous
            sell_amount = new_unlock * a.expected_sell_pressure
            total_new_unlock += sell_amount
        
        return total_new_unlock
    
    def staking_apy_at_ratio(self, staking_ratio: float) -> float:
        """
        ìŠ¤í…Œì´í‚¹ ë¹„ìœ¨ì— ë”°ë¥¸ APY ê³„ì‚°.
        
        ë©”ì»¤ë‹ˆì¦˜: ìŠ¤í…Œì´í‚¹ ë¹„ìœ¨ì´ ëª©í‘œë³´ë‹¤ ë‚®ìœ¼ë©´ APY ì¦ê°€,
                 ë†’ìœ¼ë©´ APY ê°ì†Œ â†’ ìì—°ìŠ¤ëŸ¬ìš´ ê· í˜•ì  ìœ ë„
        
        Mint: "ì´ê±´ PID ì»¨íŠ¸ë¡¤ëŸ¬ì™€ ê°™ì€ ì›ë¦¬ì˜ˆìš”. 
              ëª©í‘œì—ì„œ ë²—ì–´ë‚˜ë©´ ìë™ìœ¼ë¡œ ë³´ì •í•˜ëŠ” í”¼ë“œë°± ë£¨í”„."
        """
        if staking_ratio <= 0:
            return self.staking_apy_max
        
        ratio_factor = self.target_staking_ratio / staking_ratio
        apy = self.staking_apy_base * ratio_factor
        return min(max(apy, self.staking_apy_base * 0.5), self.staking_apy_max)
    
    def simulate(
        self, 
        months: int = 60,
        demand_growth_monthly: float = 0.02,
        initial_daily_volume_usd: float = 1_000_000,
        market_sentiment: str = 'neutral'
    ) -> pd.DataFrame:
        """
        ì¢…í•© ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰.
        
        Mintì˜ ì‹œë®¬ë ˆì´ì…˜ ì›ì¹™:
        1. ìµœì†Œ 3ë…„(36ê°œì›”) ì´ìƒ ì‹œë®¬ë ˆì´ì…˜
        2. ë‚™ê´€/ì¤‘ë¦½/ë¹„ê´€ ì‹œë‚˜ë¦¬ì˜¤ ëª¨ë‘ ê²€ì¦
        3. ê·¹ë‹¨ì  ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸ (ìˆ˜ìš” 90% ê°ì†Œ ë“±)
        
        Returns:
            DataFrame with monthly projections
        """
        logger.info(f"ğŸª™ Mint Simulation: {self.name} ({self.symbol})")
        logger.info(f"   Total Supply: {self.total_supply:,.0f}")
        logger.info(f"   Months: {months}, Sentiment: {market_sentiment}")
        
        sentiment_multiplier = {
            'bullish': 1.5,
            'neutral': 1.0,
            'bearish': 0.5,
            'extreme_bear': 0.2
        }.get(market_sentiment, 1.0)
        
        records = []
        price = self.initial_price_usd
        staking_ratio = 0.1  # ì´ˆê¸° ìŠ¤í…Œì´í‚¹ ë¹„ìœ¨ 10%
        daily_volume = initial_daily_volume_usd
        total_burned = 0
        total_bought_back = 0
        
        for month in range(months + 1):
            # 1. ìœ í†µ ê³µê¸‰ëŸ‰
            circulating = self.circulating_supply_at_month(month)
            
            # 2. ë§¤ë„ ì••ë ¥
            sell_pressure = self.effective_sell_pressure_at_month(month)
            
            # 3. ìŠ¤í…Œì´í‚¹ APY & ë¹„ìœ¨ ì¡°ì •
            current_apy = self.staking_apy_at_ratio(staking_ratio)
            # ìŠ¤í…Œì´í‚¹ ë¹„ìœ¨ì€ APYì— ë°˜ì‘í•˜ì—¬ ì ì§„ì ìœ¼ë¡œ ì¡°ì •
            target_delta = (current_apy / self.staking_apy_base - 1) * 0.02
            staking_ratio = min(0.95, max(0.05, staking_ratio + target_delta))
            
            # 4. ì†Œê° ë©”ì»¤ë‹ˆì¦˜
            monthly_tx_volume = daily_volume * 30
            monthly_burn = monthly_tx_volume * self.burn_rate_per_tx / price if price > 0 else 0
            total_burned += monthly_burn
            
            # 5. ë°”ì´ë°± ë©”ì»¤ë‹ˆì¦˜ (ìˆ˜ìµì˜ ì¼ì • ë¹„ìœ¨ë¡œ ì‹œì¥ì—ì„œ ë§¤ìˆ˜)
            estimated_revenue = monthly_tx_volume * 0.003  # 0.3% ìˆ˜ìˆ˜ë£Œ ê°€ì •
            buyback_usd = estimated_revenue * self.buyback_pct_of_revenue
            buyback_tokens = buyback_usd / price if price > 0 else 0
            total_bought_back += buyback_tokens
            
            # 6. ê°€ê²© ëª¨ë¸ (ë‹¨ìˆœí™”ëœ ìˆ˜ìš”-ê³µê¸‰ ëª¨ë¸)
            # Mint: "ì‹¤ì œ ê°€ê²© ì˜ˆì¸¡ì€ ë¶ˆê°€ëŠ¥í•˜ì§€ë§Œ, ê³µê¸‰ ì¶©ê²©ì˜ ë°©í–¥ì€ ëª¨ë¸ë§í•  ìˆ˜ ìˆë‹¤"
            effective_circulating = circulating - (circulating * staking_ratio) - total_burned
            demand_factor = (1 + demand_growth_monthly * sentiment_multiplier) ** month
            supply_factor = effective_circulating / self.total_supply if self.total_supply > 0 else 1
            
            if supply_factor > 0 and month > 0:
                price = self.initial_price_usd * demand_factor / (supply_factor * 10)
                price = max(price, self.initial_price_usd * 0.01)  # ìµœì†Œ ê°€ê²© ë°”ë‹¥
            
            # 7. ì¼ì¼ ê±°ë˜ëŸ‰ ì—…ë°ì´íŠ¸
            daily_volume = initial_daily_volume_usd * demand_factor * sentiment_multiplier
            
            # 8. ì‹œê°€ì´ì•¡
            market_cap = circulating * price
            fdv = self.total_supply * price  # Fully Diluted Valuation
            
            records.append({
                'month': month,
                'circulating_supply': circulating,
                'circulating_pct': circulating / self.total_supply * 100,
                'effective_circulating': effective_circulating,
                'staking_ratio': staking_ratio,
                'staking_apy': current_apy,
                'monthly_sell_pressure_tokens': sell_pressure,
                'total_burned': total_burned,
                'total_bought_back': total_bought_back,
                'price_usd': price,
                'market_cap_usd': market_cap,
                'fdv_usd': fdv,
                'daily_volume_usd': daily_volume,
                'mc_fdv_ratio': market_cap / fdv if fdv > 0 else 0,
            })
        
        self._simulation_results = pd.DataFrame(records)
        logger.info(f"âœ… Simulation complete. Final price: ${records[-1]['price_usd']:.4f}")
        logger.info(f"   Final MC: ${records[-1]['market_cap_usd']:,.0f}")
        logger.info(f"   Final Circ%: {records[-1]['circulating_pct']:.1f}%")
        
        return self._simulation_results
    
    def mint_test(self) -> Dict[str, bool]:
        """
        ğŸª™ ë¯¼íŠ¸ í…ŒìŠ¤íŠ¸ â€” Mintì˜ ì‹œê·¸ë‹ˆì²˜ ê²€ì¦ í”„ë ˆì„ì›Œí¬.
        
        ëª¨ë“  í† í° ëª¨ë¸ì´ í†µê³¼í•´ì•¼ í•˜ëŠ” 7ê°€ì§€ í…ŒìŠ¤íŠ¸:
        1. 36ê°œì›” í›„ ì¸í”Œë ˆì´ì…˜ì´ 5% ì´í•˜ì¸ê°€?
        2. ìµœëŒ€ ë§¤ë„ ì••ë ¥ ì›”ì´ ì „ì²´ ê³µê¸‰ì˜ 3% ë¯¸ë§Œì¸ê°€?
        3. íŒ€ ë² ìŠ¤íŒ…ì´ ìµœì†Œ 3ë…„ì¸ê°€?
        4. ì»¤ë®¤ë‹ˆí‹° í• ë‹¹ì´ 30% ì´ìƒì¸ê°€?
        5. íŠ¸ë ˆì €ë¦¬ê°€ ê±°ë²„ë„ŒìŠ¤ ê´€ë¦¬ í•˜ì— ìˆëŠ”ê°€?
        6. ìŠ¤í…Œì´í‚¹ APYê°€ ì§€ì† ê°€ëŠ¥í•œ ë²”ìœ„ì¸ê°€?
        7. FDV/MC ë¹„ìœ¨ì´ 5ë°° ì´ë‚´ë¡œ ìˆ˜ë ´í•˜ëŠ”ê°€?
        """
        if self._simulation_results is None:
            self.simulate()
        
        results = self._simulation_results
        tests = {}
        
        # Test 1: 36ê°œì›” í›„ ì¸í”Œë ˆì´ì…˜
        month_36 = results[results['month'] == 36].iloc[0] if len(results) > 36 else results.iloc[-1]
        circ_growth_36 = month_36['circulating_pct']
        tests['inflation_sustainable'] = self.annual_inflation_rate * (
            (1 - self.inflation_decay_rate) ** 3
        ) <= 0.05
        
        # Test 2: ìµœëŒ€ ë§¤ë„ ì••ë ¥
        max_sell = results['monthly_sell_pressure_tokens'].max()
        tests['sell_pressure_manageable'] = max_sell / self.total_supply < 0.03
        
        # Test 3: íŒ€ ë² ìŠ¤íŒ… ê¸°ê°„
        team_allocs = [a for a in self.allocations 
                       if a.stakeholder_type == StakeholderType.TEAM]
        tests['team_vesting_aligned'] = all(
            a.vesting.vesting_months >= 36 for a in team_allocs
        ) if team_allocs else True
        
        # Test 4: ì»¤ë®¤ë‹ˆí‹° í• ë‹¹
        community_pct = sum(
            a.allocation_pct for a in self.allocations
            if a.stakeholder_type in [
                StakeholderType.COMMUNITY,
                StakeholderType.ECOSYSTEM,
                StakeholderType.STAKING_REWARDS
            ]
        )
        tests['community_allocation_sufficient'] = community_pct >= 0.30
        
        # Test 5: íŠ¸ë ˆì €ë¦¬ ê±°ë²„ë„ŒìŠ¤
        treasury_allocs = [a for a in self.allocations
                          if a.stakeholder_type == StakeholderType.TREASURY]
        tests['treasury_governed'] = bool(treasury_allocs)  # ì¡´ì¬ ì—¬ë¶€ë§Œ ê¸°ë³¸ ì²´í¬
        
        # Test 6: ìŠ¤í…Œì´í‚¹ APY ì§€ì†ê°€ëŠ¥ì„±
        tests['staking_apy_sustainable'] = self.staking_apy_max <= 0.30
        
        # Test 7: FDV/MC ìˆ˜ë ´
        month_48 = results[results['month'] == 48].iloc[0] if len(results) > 48 else results.iloc[-1]
        fdv_mc_ratio = 1.0 / month_48['mc_fdv_ratio'] if month_48['mc_fdv_ratio'] > 0 else float('inf')
        tests['fdv_mc_converges'] = fdv_mc_ratio <= 5.0
        
        # ê²°ê³¼ ì¶œë ¥
        passed = sum(tests.values())
        total = len(tests)
        
        logger.info(f"\nğŸª™ === MINT TEST RESULTS: {self.name} ===")
        for test_name, passed_flag in tests.items():
            icon = "âœ…" if passed_flag else "âŒ"
            logger.info(f"   {icon} {test_name}")
        logger.info(f"\n   Result: {passed}/{total} passed")
        
        if passed == total:
            logger.info("   ğŸ‰ MINT TEST PASSED â€” ì´ í† í° ëª¨ë¸ì€ ì§€ì† ê°€ëŠ¥í•©ë‹ˆë‹¤!")
        elif passed >= total - 1:
            logger.info("   âš ï¸  ALMOST â€” í•œ ê°€ì§€ë§Œ ë” ê°œì„ í•˜ë©´ ë©ë‹ˆë‹¤.")
        else:
            logger.info("   ğŸš¨ FAILED â€” ê·¼ë³¸ì ì¸ ì¬ì„¤ê³„ê°€ í•„ìš”í•©ë‹ˆë‹¤.")
        
        return tests

    def visualize_supply_schedule(self, figsize: Tuple = (16, 10)):
        """
        ê³µê¸‰ ìŠ¤ì¼€ì¤„ ì‹œê°í™”.
        
        Mint: "ìˆ«ìë§Œìœ¼ë¡œëŠ” ì´í•´ê´€ê³„ìë¥¼ ì„¤ë“í•  ìˆ˜ ì—†ë‹¤.
              ì‹œê°í™”ê°€ ìŠ¤í† ë¦¬ë¥¼ ë§Œë“ ë‹¤."
        """
        fig, axes = plt.subplots(2, 2, figsize=figsize)
        fig.suptitle(f'{self.name} ({self.symbol}) â€” Token Supply Analysis by Mint ğŸª™',
                    fontsize=14, fontweight='bold')
        
        months = 60
        
        # 1. ëˆ„ì  ì–¸ë½ ì°¨íŠ¸ (Stacked Area)
        ax1 = axes[0, 0]
        month_range = range(months + 1)
        bottom = np.zeros(months + 1)
        
        colors = plt.cm.Set3(np.linspace(0, 1, len(self.allocations)))
        
        for i, alloc in enumerate(self.allocations):
            unlocked = [alloc.vesting.unlocked_at_month(m) for m in month_range]
            ax1.fill_between(month_range, bottom, bottom + unlocked,
                           alpha=0.7, label=alloc.label, color=colors[i])
            bottom = bottom + np.array(unlocked)
        
        ax1.set_xlabel('Month')
        ax1.set_ylabel('Tokens')
        ax1.set_title('Cumulative Token Unlock Schedule')
        ax1.legend(fontsize=8, loc='upper left')
        ax1.axhline(y=self.total_supply, color='red', linestyle='--', alpha=0.5,
                    label='Total Supply')
        
        # 2. ì›”ë³„ ì‹ ê·œ ì–¸ë½ëŸ‰
        ax2 = axes[0, 1]
        for i, alloc in enumerate(self.allocations):
            monthly = alloc.vesting.monthly_unlock_schedule(months)
            ax2.bar(monthly.index, monthly.values, alpha=0.6,
                   label=alloc.label, color=colors[i], width=0.8)
        
        ax2.set_xlabel('Month')
        ax2.set_ylabel('New Tokens Unlocked')
        ax2.set_title('Monthly New Unlock (Sell Pressure Indicator)')
        
        # 3. ìœ í†µ ë¹„ìœ¨
        ax3 = axes[1, 0]
        if self._simulation_results is not None:
            ax3.plot(self._simulation_results['month'],
                    self._simulation_results['circulating_pct'],
                    color='#2ecc71', linewidth=2)
            ax3.fill_between(self._simulation_results['month'],
                           0, self._simulation_results['circulating_pct'],
                           alpha=0.2, color='#2ecc71')
        ax3.set_xlabel('Month')
        ax3.set_ylabel('Circulating %')
        ax3.set_title('Circulating Supply Ratio')
        ax3.axhline(y=100, color='red', linestyle='--', alpha=0.3)
        
        # 4. MC/FDV ë¹„ìœ¨
        ax4 = axes[1, 1]
        if self._simulation_results is not None:
            ax4.plot(self._simulation_results['month'],
                    self._simulation_results['mc_fdv_ratio'],
                    color='#e74c3c', linewidth=2)
        ax4.set_xlabel('Month')
        ax4.set_ylabel('MC / FDV Ratio')
        ax4.set_title('Market Cap to FDV Convergence')
        ax4.axhline(y=1.0, color='green', linestyle='--', alpha=0.3, label='Full Dilution')
        
        plt.tight_layout()
        return fig


class MintScenarioAnalyzer:
    """
    Mintì˜ ì‹œë‚˜ë¦¬ì˜¤ ë¶„ì„ í”„ë ˆì„ì›Œí¬.
    
    "í•˜ë‚˜ì˜ ì‹œë‚˜ë¦¬ì˜¤ë§Œ ë¶„ì„í•˜ëŠ” ê±´ í•œìª½ ëˆˆì„ ê°ê³  ìš´ì „í•˜ëŠ” ê²ƒê³¼ ê°™ë‹¤.
    ìµœì†Œ ë‚™ê´€/ì¤‘ë¦½/ë¹„ê´€, ê·¸ë¦¬ê³  ë¸”ë™ìŠ¤ì™„ê¹Œì§€." â€” Mint
    """
    
    SCENARIOS = {
        'bull_case': {
            'demand_growth': 0.05,
            'volume_multiplier': 3.0,
            'sentiment': 'bullish',
            'description': 'ê°•ì„¸ì¥ â€” í¬ë¦½í†  ì‹œì¥ ì „ì²´ ìƒìŠ¹, ë†’ì€ ìˆ˜ìš”'
        },
        'base_case': {
            'demand_growth': 0.02,
            'volume_multiplier': 1.0,
            'sentiment': 'neutral',
            'description': 'ê¸°ë³¸ ì‹œë‚˜ë¦¬ì˜¤ â€” ì•ˆì •ì  ì„±ì¥'
        },
        'bear_case': {
            'demand_growth': -0.01,
            'volume_multiplier': 0.4,
            'sentiment': 'bearish',
            'description': 'ì•½ì„¸ì¥ â€” ì‹œì¥ í•˜ë½, ìˆ˜ìš” ê°ì†Œ'
        },
        'black_swan': {
            'demand_growth': -0.05,
            'volume_multiplier': 0.1,
            'sentiment': 'extreme_bear',
            'description': 'ë¸”ë™ìŠ¤ì™„ â€” ê·¹ë‹¨ì  ì‹œì¥ ë¶•ê´´ (UST/LUNAê¸‰ ì´ë²¤íŠ¸)'
        }
    }
    
    def __init__(self, model: TokenModel):
        self.model = model
        self.results = {}
    
    def run_all_scenarios(self, months: int = 60) -> Dict[str, pd.DataFrame]:
        """ëª¨ë“  ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰ ë° ë¹„êµ"""
        logger.info("ğŸª™ Mint Scenario Analysis â€” Running all scenarios...")
        
        for name, params in self.SCENARIOS.items():
            logger.info(f"\nğŸ“Š Scenario: {name} â€” {params['description']}")
            
            # ëª¨ë¸ ë³µì‚¬ í›„ ì‹œë®¬ë ˆì´ì…˜
            import copy
            model_copy = copy.deepcopy(self.model)
            result = model_copy.simulate(
                months=months,
                demand_growth_monthly=params['demand_growth'],
                initial_daily_volume_usd=1_000_000 * params['volume_multiplier'],
                market_sentiment=params['sentiment']
            )
            self.results[name] = result
        
        return self.results
    
    def survival_analysis(self) -> Dict[str, any]:
        """
        ìƒì¡´ ë¶„ì„ â€” "ì´ í† í°ì´ 3ë…„ í›„ì—ë„ ì‚´ì•„ìˆì„ í™•ë¥ "
        
        Mintì˜ ìƒì¡´ ê¸°ì¤€:
        1. ê°€ê²©ì´ TGE ëŒ€ë¹„ 10% ì´ìƒ ìœ ì§€
        2. ì¼ì¼ ê±°ë˜ëŸ‰ $100K ì´ìƒ
        3. ìŠ¤í…Œì´í‚¹ ë¹„ìœ¨ 20% ì´ìƒ
        """
        survival = {}
        
        for name, result in self.results.items():
            month_36 = result[result['month'] == 36]
            if len(month_36) == 0:
                continue
            
            row = month_36.iloc[0]
            initial_price = result.iloc[0]['price_usd']
            
            criteria = {
                'price_above_10pct': row['price_usd'] >= initial_price * 0.1,
                'volume_above_100k': row['daily_volume_usd'] >= 100_000,
                'staking_above_20pct': row['staking_ratio'] >= 0.2,
            }
            
            survival[name] = {
                'criteria': criteria,
                'survives': all(criteria.values()),
                'score': sum(criteria.values()) / len(criteria)
            }
        
        return survival


# ============================================================================
# Section 3: ê±°ë²„ë„ŒìŠ¤ ëª¨ë¸ â€” "ê±°ë²„ë„ŒìŠ¤ëŠ” ì¸ì„¼í‹°ë¸Œì˜ ìµœì¢… í‘œí˜„ì´ë‹¤"
# ============================================================================

class GovernanceModel:
    """
    ì˜¨ì²´ì¸ ê±°ë²„ë„ŒìŠ¤ ì„¤ê³„ í”„ë ˆì„ì›Œí¬.
    
    Mint: "ì¢‹ì€ ê±°ë²„ë„ŒìŠ¤ëŠ” ì°¸ì—¬ë¥¼ ë³´ìƒí•˜ê³ , ë¬´ê´€ì‹¬ì„ ë²Œí•˜ë©°,
          ê³µê²©ì„ ê²½ì œì ìœ¼ë¡œ ë¶ˆê°€ëŠ¥í•˜ê²Œ ë§Œë“ ë‹¤."
    """
    
    @dataclass
    class GovernanceParams:
        """ê±°ë²„ë„ŒìŠ¤ í•µì‹¬ íŒŒë¼ë¯¸í„°"""
        proposal_threshold_pct: float = 0.01     # ì œì•ˆ ìµœì†Œ í† í° ë¹„ìœ¨ (1%)
        quorum_pct: float = 0.04                  # ì¿¼ëŸ¼ ë¹„ìœ¨ (4%)
        voting_period_blocks: int = 50400          # íˆ¬í‘œ ê¸°ê°„ (~7ì¼)
        voting_delay_blocks: int = 7200            # íˆ¬í‘œ ì§€ì—° (~1ì¼)
        timelock_delay_seconds: int = 172800       # íƒ€ì„ë½ (48ì‹œê°„)
        
        # Mint í™•ì¥ íŒŒë¼ë¯¸í„°
        vote_weight_decay: bool = True             # ì¥ê¸° ë³´ìœ ì ê°€ì¤‘ íˆ¬í‘œ
        delegation_enabled: bool = True            # ìœ„ì„ í—ˆìš©
        quadratic_voting: bool = False             # ì œê³±ê·¼ íˆ¬í‘œ (ì‹¤í—˜ì )
        rage_quit_enabled: bool = True             # ë¶„ë…¸ í‡´ì¥ ë©”ì»¤ë‹ˆì¦˜
        optimistic_governance: bool = False        # ë‚™ê´€ì  ê±°ë²„ë„ŒìŠ¤
        
        # ë³´ìƒ ë©”ì»¤ë‹ˆì¦˜
        voter_reward_pct: float = 0.001           # íˆ¬í‘œ ì°¸ì—¬ ë³´ìƒ (ì´ ê³µê¸‰ì˜ 0.1%)
        delegate_bonus_pct: float = 0.0005        # ìœ„ì„ì ë³´ë„ˆìŠ¤
    
    @staticmethod
    def calculate_attack_cost(
        token_price: float,
        total_supply: int,
        circulating_supply: int,
        quorum_pct: float,
        current_staking_ratio: float
    ) -> Dict[str, float]:
        """
        ê±°ë²„ë„ŒìŠ¤ ê³µê²© ë¹„ìš© ë¶„ì„.
        
        Mint: "ê±°ë²„ë„ŒìŠ¤ ë³´ì•ˆì˜ í•µì‹¬ì€ ê²½ì œì  ë³´ì•ˆì´ë‹¤.
              ê³µê²© ë¹„ìš©ì´ ê³µê²© ì´ìµë³´ë‹¤ í›¨ì”¬ ì»¤ì•¼ í•œë‹¤."
        
        ë¶„ì„í•˜ëŠ” ê³µê²© ë²¡í„°:
        1. ì§ì ‘ ë§¤ìˆ˜ ê³µê²© â€” ì‹œì¥ì—ì„œ ì¿¼ëŸ¼ ì´ìƒ ë§¤ìˆ˜
        2. í”Œë˜ì‹œë¡  ê³µê²© â€” ì°¨ì…ì„ í†µí•œ ì¼ì‹œì  íˆ¬í‘œê¶Œ í™•ë³´
        3. ë‡Œë¬¼ ê³µê²© â€” ê¸°ì¡´ ë³´ìœ ìì—ê²Œ íˆ¬í‘œ ë§¤ìˆ˜
        """
        quorum_tokens = total_supply * quorum_pct
        available_tokens = circulating_supply * (1 - current_staking_ratio)
        
        # 1. ì§ì ‘ ë§¤ìˆ˜ ê³µê²© ë¹„ìš© (ìŠ¬ë¦¬í”¼ì§€ í¬í•¨)
        tokens_needed = quorum_tokens
        # ê°„ë‹¨í•œ ìŠ¬ë¦¬í”¼ì§€ ëª¨ë¸: ë§¤ìˆ˜ëŸ‰ì´ ìœ í†µëŸ‰ì˜ X% â†’ X% ê°€ê²© ì˜í–¥
        buy_pct = tokens_needed / available_tokens
        average_slippage = 1 + (buy_pct * 2)  # 2x ìŠ¬ë¦¬í”¼ì§€ ê°€ì •
        direct_buy_cost = tokens_needed * token_price * average_slippage
        
        # 2. í”Œë˜ì‹œë¡  ê³µê²© (ê°€ëŠ¥ ì—¬ë¶€ & ë¹„ìš©)
        flash_loan_fee_pct = 0.0009  # Aave 0.09%
        flash_loan_cost = tokens_needed * token_price * flash_loan_fee_pct
        
        # 3. ë‡Œë¬¼ ê³µê²© ë¹„ìš©
        # ë³´ìœ ìê°€ íˆ¬í‘œë¥¼ ë§¤ë„í•˜ë ¤ë©´ ìµœì†Œí•œ ìŠ¤í…Œì´í‚¹ ìˆ˜ìµ ì´ìƒ ë°›ì•„ì•¼ í•¨
        annual_staking_reward = token_price * 0.05  # 5% APY ê°€ì •
        voting_period_reward = annual_staking_reward * (7 / 365)  # 7ì¼ì¹˜
        bribe_per_token = voting_period_reward * 2  # 2ë°° í”„ë¦¬ë¯¸ì—„
        bribe_cost = quorum_tokens * bribe_per_token
        
        return {
            'direct_buy_cost_usd': direct_buy_cost,
            'flash_loan_cost_usd': flash_loan_cost,
            'flash_loan_possible': buy_pct <= 0.5,  # ìœ í†µëŸ‰ì˜ 50% ì´ìƒ ì°¨ì… ë¶ˆê°€
            'bribe_cost_usd': bribe_cost,
            'min_attack_cost_usd': min(direct_buy_cost, bribe_cost),
            'tokens_needed': quorum_tokens,
            'pct_of_circulating': buy_pct * 100,
        }
    
    @staticmethod  
    def optimal_quorum(
        total_supply: int,
        expected_participation_rate: float = 0.15,
        target_security_usd: float = 10_000_000,
        token_price: float = 1.0
    ) -> float:
        """
        ìµœì  ì¿¼ëŸ¼ ê³„ì‚°.
        
        Mintì˜ ì¿¼ëŸ¼ ë”œë ˆë§ˆ:
        - ì¿¼ëŸ¼ì´ ë„ˆë¬´ ë†’ìœ¼ë©´ â†’ ì œì•ˆì´ í†µê³¼ë˜ì§€ ì•Šì•„ ê±°ë²„ë„ŒìŠ¤ ë§ˆë¹„
        - ì¿¼ëŸ¼ì´ ë„ˆë¬´ ë‚®ìœ¼ë©´ â†’ ì†Œìˆ˜ê°€ í”„ë¡œí† ì½œì„ ì¥ì•… ê°€ëŠ¥
        
        ìµœì ì : ê³µê²© ë¹„ìš© > ëª©í‘œ ë³´ì•ˆ ìˆ˜ì¤€ & ì°¸ì—¬ìœ¨ì˜ 80% ìˆ˜ì¤€
        """
        # ì°¸ì—¬ìœ¨ì˜ 80%ì—ì„œ ì¿¼ëŸ¼ ë‹¬ì„± ê°€ëŠ¥í•˜ë„ë¡
        participation_based = expected_participation_rate * 0.8
        
        # ë³´ì•ˆ ê¸°ë°˜ ìµœì†Œ ì¿¼ëŸ¼
        security_based = target_security_usd / (total_supply * token_price)
        
        # ë‘ ê¸°ì¤€ ì¤‘ ë†’ì€ ê°’ ì„ íƒ
        optimal = max(participation_based, security_based)
        
        # í•©ë¦¬ì  ë²”ìœ„ë¡œ í´ë¨í•‘ (1% ~ 20%)
        return min(max(optimal, 0.01), 0.20)


# ============================================================================
# Section 4: ì¸ì„¼í‹°ë¸Œ ì„¤ê³„ â€” "ì¸ì„¼í‹°ë¸Œê°€ í–‰ë™ì„ ë§Œë“ ë‹¤"
# ============================================================================

class IncentiveDesigner:
    """
    Mintì˜ ì¸ì„¼í‹°ë¸Œ ì„¤ê³„ ë„êµ¬.
    
    "ê²Œì„ ì´ë¡ ì´ ì´ë¡ ìœ¼ë¡œë§Œ ë‚¨ìœ¼ë©´ ì•ˆ ëœë‹¤.
    ì‹¤ì œ í”„ë¡œí† ì½œì˜ ì¸ì„¼í‹°ë¸Œë¡œ êµ¬í˜„ë˜ì–´ì•¼ í•œë‹¤." â€” Mint
    """
    
    @staticmethod
    def design_liquidity_mining(
        total_reward_tokens: int,
        duration_months: int,
        pools: List[Dict],
        decay_type: str = 'halving'
    ) -> pd.DataFrame:
        """
        ìœ ë™ì„± ë§ˆì´ë‹ ë³´ìƒ ìŠ¤ì¼€ì¤„ ì„¤ê³„.
        
        Mintì˜ ìœ ë™ì„± ë§ˆì´ë‹ ì›ì¹™:
        1. ì´ˆê¸° ë³´ìƒì€ ë†’ê²Œ â€” ë¶€íŠ¸ìŠ¤íŠ¸ë© íš¨ê³¼
        2. ì ì§„ì  ê°ì†Œ â€” ìš©ë³‘ ìë³¸ ìµœì†Œí™”
        3. ì¥ê¸° LPì—ê²Œ ë³´ë„ˆìŠ¤ â€” ì¶©ì„±ë„ ë³´ìƒ
        4. ë³´ìƒ ì´ëŸ‰ ì œí•œ â€” ì¸í”Œë ˆì´ì…˜ í†µì œ
        """
        schedule = []
        remaining = total_reward_tokens
        
        for month in range(1, duration_months + 1):
            if decay_type == 'halving':
                # 6ê°œì›”ë§ˆë‹¤ ë°˜ê°ê¸°
                halving_period = 6
                halvings = (month - 1) // halving_period
                monthly_rate = 1.0 / (2 ** halvings)
            elif decay_type == 'linear':
                monthly_rate = 1 - (month / duration_months)
            elif decay_type == 'sqrt':
                # ì œê³±ê·¼ ê°ì†Œ â€” ì´ˆê¸° ê¸‰ê° í›„ ì™„ë§Œ
                monthly_rate = np.sqrt(1 - (month / duration_months))
            else:
                monthly_rate = 1.0
            
            base_monthly = total_reward_tokens / duration_months
            monthly_reward = base_monthly * monthly_rate
            monthly_reward = min(monthly_reward, remaining)
            remaining -= monthly_reward
            
            # í’€ë³„ ë°°ë¶„
            total_weight = sum(p.get('weight', 1) for p in pools)
            
            for pool in pools:
                pool_weight = pool.get('weight', 1) / total_weight
                pool_reward = monthly_reward * pool_weight
                
                schedule.append({
                    'month': month,
                    'pool': pool['name'],
                    'reward_tokens': pool_reward,
                    'pool_weight_pct': pool_weight * 100,
                    'cumulative_remaining': remaining,
                    'decay_rate': monthly_rate
                })
        
        return pd.DataFrame(schedule)
    
    @staticmethod
    def nash_equilibrium_check(
        strategy_matrix: np.ndarray,
        player_labels: List[str] = None
    ) -> Dict:
        """
        ë‹¨ìˆœ 2ì¸ ê²Œì„ì˜ ë‚´ì‰¬ ê· í˜• ê²€ì‚¬.
        
        Mint: "ëª¨ë“  í”„ë¡œí† ì½œ ì¸ì„¼í‹°ë¸ŒëŠ” ë‚´ì‰¬ ê· í˜•ì—ì„œ
              ë°”ëŒì§í•œ í–‰ë™ì´ ìš°ì„¸ ì „ëµì´ ë˜ì–´ì•¼ í•œë‹¤."
        
        Args:
            strategy_matrix: 2D array, rows=Player1 strategies, 
                           cols=Player2 strategies
                           Each cell = (payoff_p1, payoff_p2) as tuple
        """
        rows, cols = strategy_matrix.shape[:2]
        nash_equilibria = []
        
        for i in range(rows):
            for j in range(cols):
                p1_payoff = strategy_matrix[i, j, 0]
                p2_payoff = strategy_matrix[i, j, 1]
                
                # P1ì˜ ìµœì  ë°˜ì‘ í™•ì¸ (j ê³ ì •, ë‹¤ë¥¸ iì—ì„œ ë” ë†’ì€ ë³´ìƒ ì—†ëŠ”ì§€)
                p1_best = all(
                    p1_payoff >= strategy_matrix[k, j, 0]
                    for k in range(rows)
                )
                
                # P2ì˜ ìµœì  ë°˜ì‘ í™•ì¸ (i ê³ ì •, ë‹¤ë¥¸ jì—ì„œ ë” ë†’ì€ ë³´ìƒ ì—†ëŠ”ì§€)
                p2_best = all(
                    p2_payoff >= strategy_matrix[i, k, 1]
                    for k in range(cols)
                )
                
                if p1_best and p2_best:
                    nash_equilibria.append({
                        'p1_strategy': i,
                        'p2_strategy': j,
                        'p1_payoff': p1_payoff,
                        'p2_payoff': p2_payoff,
                    })
        
        return {
            'equilibria': nash_equilibria,
            'count': len(nash_equilibria),
            'has_dominant_strategy': any(
                eq['p1_payoff'] > 0 and eq['p2_payoff'] > 0
                for eq in nash_equilibria
            )
        }
    
    @staticmethod
    def vetoken_model(
        lock_durations_weeks: List[int],
        base_tokens: float,
        max_boost: float = 4.0
    ) -> pd.DataFrame:
        """
        ve(vote-escrowed) í† í° ëª¨ë¸ ì„¤ê³„.
        
        Curve Financeì˜ veCRV ëª¨ë¸ì„ ì¼ë°˜í™”í•œ í”„ë ˆì„ì›Œí¬.
        
        Mint: "ve ëª¨ë¸ì€ í˜„ì¬ê¹Œì§€ ë°œê²¬ëœ ê°€ì¥ ìš°ì•„í•œ ì¸ì„¼í‹°ë¸Œ ì •ë ¬ ë©”ì»¤ë‹ˆì¦˜ì´ë‹¤.
              ì‹œê°„ ì„ í˜¸ë„ë¥¼ íˆ¬í‘œ ê¶Œí•œìœ¼ë¡œ ë³€í™˜í•œë‹¤."
        
        ì›ë¦¬:
        - í† í°ì„ ì¥ê¸°ê°„ ì ê·¸ë©´ ë” ë§ì€ íˆ¬í‘œ ê¶Œí•œ(veToken) íšë“
        - veTokenì€ ì‹œê°„ì´ ì§€ë‚˜ë©´ì„œ ì„ í˜• ê°ì†Œ
        - ìµœëŒ€ ì ê¸ˆ = ìµœëŒ€ ë¶€ìŠ¤íŠ¸
        """
        max_lock_weeks = max(lock_durations_weeks)
        records = []
        
        for lock_weeks in lock_durations_weeks:
            # veToken ëŸ‰ = base_tokens * (lock_weeks / max_lock_weeks) * max_boost
            ve_amount = base_tokens * (lock_weeks / max_lock_weeks) * max_boost
            boost_factor = lock_weeks / max_lock_weeks * max_boost
            
            # ì‹œê°„ì— ë”°ë¥¸ veToken ê°ì†Œ ì‹œë®¬ë ˆì´ì…˜
            for week in range(lock_weeks + 1):
                remaining_weeks = lock_weeks - week
                current_ve = base_tokens * (remaining_weeks / max_lock_weeks) * max_boost
                
                records.append({
                    'lock_duration_weeks': lock_weeks,
                    'current_week': week,
                    'remaining_weeks': remaining_weeks,
                    've_balance': current_ve,
                    'boost_factor': current_ve / base_tokens if base_tokens > 0 else 0,
                    'voting_power_pct': (current_ve / (base_tokens * max_boost)) * 100
                })
        
        return pd.DataFrame(records)


# ============================================================================
# Section 5: ì‹¤ì „ ì‚¬ìš© ì˜ˆì‹œ â€” "ë§ˆì•¼í¬ë£¨ í”„ë¡œì íŠ¸ ì ìš©"
# ============================================================================

def maya_token_design_example():
    """
    ë§ˆì•¼í¬ë£¨ í† í° ì„¤ê³„ ì˜ˆì‹œ.
    
    Mintê°€ ì‹¤ì œë¡œ ë§ˆì•¼í¬ë£¨ í”„ë¡œì íŠ¸ì— ì ìš©í•˜ëŠ” 
    í† í° ì´ì½”ë…¸ë¯¹ìŠ¤ ì„¤ê³„ í”Œë¡œìš°.
    """
    
    # Step 1: í• ë‹¹ êµ¬ì¡° ì •ì˜
    allocations = [
        StakeholderAllocation(
            stakeholder_type=StakeholderType.TEAM,
            label="Team & Founders",
            allocation_pct=0.15,
            vesting=VestingSchedule(
                vesting_type=VestingType.CLIFF_LINEAR,
                total_allocation=150_000_000,
                cliff_months=12,
                vesting_months=48,
                tge_unlock_pct=0.0
            ),
            expected_sell_pressure=0.2,
            governance_weight=1.0
        ),
        StakeholderAllocation(
            stakeholder_type=StakeholderType.INVESTOR_SEED,
            label="Seed Round",
            allocation_pct=0.08,
            vesting=VestingSchedule(
                vesting_type=VestingType.CLIFF_LINEAR,
                total_allocation=80_000_000,
                cliff_months=12,
                vesting_months=36,
                tge_unlock_pct=0.0
            ),
            expected_sell_pressure=0.4
        ),
        StakeholderAllocation(
            stakeholder_type=StakeholderType.INVESTOR_SERIES_A,
            label="Series A",
            allocation_pct=0.10,
            vesting=VestingSchedule(
                vesting_type=VestingType.CLIFF_LINEAR,
                total_allocation=100_000_000,
                cliff_months=6,
                vesting_months=30,
                tge_unlock_pct=0.0
            ),
            expected_sell_pressure=0.35
        ),
        StakeholderAllocation(
            stakeholder_type=StakeholderType.COMMUNITY,
            label="Community & Airdrops",
            allocation_pct=0.20,
            vesting=VestingSchedule(
                vesting_type=VestingType.LINEAR,
                total_allocation=200_000_000,
                vesting_months=36,
                tge_unlock_pct=0.10  # 10% TGE ì¦‰ì‹œ ì–¸ë½
            ),
            expected_sell_pressure=0.6
        ),
        StakeholderAllocation(
            stakeholder_type=StakeholderType.TREASURY,
            label="DAO Treasury",
            allocation_pct=0.20,
            vesting=VestingSchedule(
                vesting_type=VestingType.MILESTONE,
                total_allocation=200_000_000,
                vesting_months=60,
                tge_unlock_pct=0.0,
                dynamic_params={
                    'milestones': [
                        {'month': 6, 'pct': 0.10, 'condition': 'DAO ì¶œë²”'},
                        {'month': 12, 'pct': 0.15, 'condition': 'TVL $100M ë‹¬ì„±'},
                        {'month': 24, 'pct': 0.25, 'condition': 'Protocol Revenue $10M'},
                        {'month': 36, 'pct': 0.25, 'condition': 'Ecosystem 50+ Projects'},
                        {'month': 48, 'pct': 0.25, 'condition': 'ì™„ì „ íƒˆì¤‘ì•™í™”'},
                    ]
                }
            ),
            expected_sell_pressure=0.1,
            governance_weight=0.0  # íŠ¸ë ˆì €ë¦¬ ìì²´ëŠ” íˆ¬í‘œ ì•ˆí•¨
        ),
        StakeholderAllocation(
            stakeholder_type=StakeholderType.ECOSYSTEM,
            label="Ecosystem Incentives",
            allocation_pct=0.15,
            vesting=VestingSchedule(
                vesting_type=VestingType.LINEAR,
                total_allocation=150_000_000,
                vesting_months=48,
                tge_unlock_pct=0.05
            ),
            expected_sell_pressure=0.3
        ),
        StakeholderAllocation(
            stakeholder_type=StakeholderType.LIQUIDITY,
            label="Liquidity Bootstrap",
            allocation_pct=0.05,
            vesting=VestingSchedule(
                vesting_type=VestingType.LINEAR,
                total_allocation=50_000_000,
                vesting_months=6,
                tge_unlock_pct=0.50  # 50% ì¦‰ì‹œ DEX ìœ ë™ì„±
            ),
            expected_sell_pressure=0.1  # ìœ ë™ì„±ì´ë¯€ë¡œ ë§¤ë„ê°€ ì•„ë‹˜
        ),
        StakeholderAllocation(
            stakeholder_type=StakeholderType.ADVISORS,
            label="Advisors",
            allocation_pct=0.03,
            vesting=VestingSchedule(
                vesting_type=VestingType.CLIFF_LINEAR,
                total_allocation=30_000_000,
                cliff_months=6,
                vesting_months=24,
                tge_unlock_pct=0.0
            ),
            expected_sell_pressure=0.5
        ),
        StakeholderAllocation(
            stakeholder_type=StakeholderType.STAKING_REWARDS,
            label="Staking Rewards Pool",
            allocation_pct=0.04,
            vesting=VestingSchedule(
                vesting_type=VestingType.LINEAR,
                total_allocation=40_000_000,
                vesting_months=60,
                tge_unlock_pct=0.0
            ),
            expected_sell_pressure=0.15
        ),
    ]
    
    # Step 2: ëª¨ë¸ ìƒì„±
    model = TokenModel(
        name="MayaCrew Token",
        symbol="MAYA",
        total_supply=1_000_000_000,
        initial_price_usd=0.10,
        allocations=allocations,
        annual_inflation_rate=0.03,       # ì—° 3% ì¸í”Œë ˆì´ì…˜
        inflation_decay_rate=0.15,        # ë§¤ë…„ 15%ì”© ì¸í”Œë ˆì´ì…˜ ê°ì†Œ
        burn_rate_per_tx=0.001,           # íŠ¸ëœì­ì…˜ë‹¹ 0.1% ì†Œê°
        buyback_pct_of_revenue=0.20,      # ìˆ˜ìµì˜ 20% ë°”ì´ë°±
        target_staking_ratio=0.45,        # ëª©í‘œ 45% ìŠ¤í…Œì´í‚¹
        staking_apy_base=0.08,            # ê¸°ë³¸ 8% APY
        staking_apy_max=0.25              # ìµœëŒ€ 25% APY
    )
    
    # Step 3: ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰
    results = model.simulate(months=60, market_sentiment='neutral')
    
    # Step 4: ë¯¼íŠ¸ í…ŒìŠ¤íŠ¸
    test_results = model.mint_test()
    
    # Step 5: ì‹œë‚˜ë¦¬ì˜¤ ë¶„ì„
    analyzer = MintScenarioAnalyzer(model)
    scenario_results = analyzer.run_all_scenarios()
    survival = analyzer.survival_analysis()
    
    return model, results, test_results, survival


# ============================================================================
# Section 6: ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ â€” "ìì£¼ ì“°ëŠ” ê³„ì‚°ì€ í•¨ìˆ˜ë¡œ"
# ============================================================================

def calculate_fdv_mc_ratio(
    total_supply: int,
    circulating_supply: int,
    price: float
) -> Dict[str, float]:
    """FDVì™€ ì‹œê°€ì´ì•¡ ë¹„ìœ¨ ê³„ì‚° â€” Mintì˜ ê¸°ë³¸ ë°¸ë¥˜ì—ì´ì…˜ ë„êµ¬"""
    mc = circulating_supply * price
    fdv = total_supply * price
    return {
        'market_cap': mc,
        'fdv': fdv,
        'ratio': fdv / mc if mc > 0 else float('inf'),
        'circulating_pct': circulating_supply / total_supply * 100
    }


def token_velocity(
    daily_volume: float,
    market_cap: float,
    days: int = 365
) -> float:
    """
    í† í° ì†ë„ ê³„ì‚°.
    
    Mint: "ë†’ì€ í† í° ì†ë„ëŠ” ê°€ì¹˜ ì €ì¥ ê¸°ëŠ¥ì´ ì•½í•˜ë‹¤ëŠ” ì‹ í˜¸.
          ì†ë„ë¥¼ ë‚®ì¶”ëŠ” ë©”ì»¤ë‹ˆì¦˜(ìŠ¤í…Œì´í‚¹, ì ê¸ˆ)ì´ í•„ìš”í•˜ë‹¤."
    
    velocity = (daily_volume * days) / market_cap
    """
    annual_volume = daily_volume * days
    return annual_volume / market_cap if market_cap > 0 else float('inf')


def gini_coefficient(holdings: np.ndarray) -> float:
    """
    í† í° ë¶„ë°°ì˜ ì§€ë‹ˆ ê³„ìˆ˜ ê³„ì‚°.
    
    Mint: "ì§€ë‹ˆ ê³„ìˆ˜ê°€ 0.8 ì´ìƒì´ë©´ ê³ ë˜ ë¦¬ìŠ¤í¬ê°€ ë†’ë‹¤.
          ê±´ê°•í•œ í”„ë¡œí† ì½œì€ 0.5~0.7 ë²”ìœ„ë¥¼ ìœ ì§€í•´ì•¼ í•œë‹¤."
    """
    sorted_holdings = np.sort(holdings)
    n = len(sorted_holdings)
    cumulative = np.cumsum(sorted_holdings)
    return (2 * np.sum((np.arange(1, n + 1) * sorted_holdings)) / 
            (n * np.sum(sorted_holdings)) - (n + 1) / n)


def herfindahl_index(holdings: np.ndarray) -> float:
    """
    í—ˆí•€ë‹¬-í—ˆì‰¬ë§Œ ì§€ìˆ˜ (HHI) â€” í† í° ì§‘ì¤‘ë„ ì¸¡ì •.
    
    HHI < 0.01: ë§¤ìš° ë¶„ì‚°
    HHI 0.01-0.15: ì ë‹¹í•œ ë¶„ì‚°
    HHI 0.15-0.25: ì§‘ì¤‘ì 
    HHI > 0.25: ë§¤ìš° ì§‘ì¤‘ (ê³ ë˜ ì§€ë°°)
    """
    total = holdings.sum()
    shares = holdings / total
    return np.sum(shares ** 2)


if __name__ == "__main__":
    print("ğŸª™ Mint's Token Economics Framework v3.2.1")
    print("=" * 60)
    model, results, tests, survival = maya_token_design_example()
    print("\nğŸ“Š Simulation Results (first 12 months):")
    print(results[['month', 'circulating_pct', 'price_usd', 'market_cap_usd']].head(13))
    print(f"\nğŸª™ Mint Test: {sum(tests.values())}/{len(tests)} passed")
    print(f"\nğŸ”® Survival Analysis:")
    for scenario, data in survival.items():
        icon = "âœ…" if data['survives'] else "âŒ"
        print(f"   {icon} {scenario}: score={data['score']:.1%}")
```

### 3.3 ì†”ë¦¬ë””í‹° ê±°ë²„ë„ŒìŠ¤ ì»¨íŠ¸ë™íŠ¸ ì„¤ê³„

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title MintGovernor â€” Mintì˜ í™•ì¥í˜• ê±°ë²„ë„ŒìŠ¤ ì»¨íŠ¸ë™íŠ¸
 * @author Mint (Jung Subin) / F1-24
 * @notice OpenZeppelin Governorë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë§ˆì•¼í¬ë£¨ ê³ ìœ  ê¸°ëŠ¥ ì¶”ê°€
 * 
 * Mint's Design Principles:
 * 1. "ì œì•ˆì€ ëˆ„êµ¬ë‚˜, íˆ¬í‘œëŠ” ìŠ¤í…Œì´ì»¤ë§Œ, ì‹¤í–‰ì€ íƒ€ì„ë½ìœ¼ë¡œ"
 * 2. "ê²½ì œì  ë³´ì•ˆ > ì½”ë“œ ë³´ì•ˆ (ë‘˜ ë‹¤ í•„ìˆ˜ì§€ë§Œ)"
 * 3. "ê±°ë²„ë„ŒìŠ¤ ì°¸ì—¬ì—ëŠ” ë³´ìƒì´ ë”°ë¼ì•¼ í•œë‹¤"
 *
 * Extensions over vanilla Governor:
 * - Vote weight decay based on lock duration (ve-style)
 * - Voter participation rewards
 * - Quadratic voting option for specific proposal types
 * - Rage quit mechanism for minority protection
 * - Treasury spending limits per epoch
 */

import "@openzeppelin/contracts/governance/Governor.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorSettings.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorVotes.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorVotesQuorumFraction.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

/**
 * @title IVeToken â€” Vote-Escrowed í† í° ì¸í„°í˜ì´ìŠ¤
 * @notice Mint: "ve í† í°ì€ ì‹œê°„ ì„ í˜¸ë„ë¥¼ ì˜¨ì²´ì¸ìœ¼ë¡œ í‘œí˜„í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜"
 */
interface IVeToken {
    function balanceOf(address account) external view returns (uint256);
    function lockEnd(address account) external view returns (uint256);
    function totalSupply() external view returns (uint256);
}

/**
 * @title ITreasury â€” íŠ¸ë ˆì €ë¦¬ ì¸í„°í˜ì´ìŠ¤
 */
interface ITreasury {
    function balance() external view returns (uint256);
    function epochSpent(uint256 epoch) external view returns (uint256);
}

contract MintGovernor is 
    Governor,
    GovernorSettings,
    GovernorCountingSimple,
    GovernorVotes,
    GovernorVotesQuorumFraction,
    GovernorTimelockControl,
    AccessControl
{
    // ================================================================
    // State Variables â€” "ëª¨ë“  ìƒíƒœëŠ” íˆ¬ëª…í•˜ê²Œ"
    // ================================================================
    
    bytes32 public constant GUARDIAN_ROLE = keccak256("GUARDIAN_ROLE");
    
    /// @notice veí† í° ì»¨íŠ¸ë™íŠ¸ (íˆ¬í‘œ ê°€ì¤‘ì¹˜ ê²°ì •)
    IVeToken public immutable veToken;
    
    /// @notice íŠ¸ë ˆì €ë¦¬ ì»¨íŠ¸ë™íŠ¸ (ì§€ì¶œ í•œë„ ê´€ë¦¬)
    ITreasury public treasury;
    
    /// @notice ì—í¬í¬ë‹¹ íŠ¸ë ˆì €ë¦¬ ì§€ì¶œ í•œë„ (basis points, 10000 = 100%)
    uint256 public treasurySpendLimitBps = 1000; // 10% per epoch
    
    /// @notice ì—í¬í¬ ê¸°ê°„ (ë¸”ë¡ ìˆ˜)
    uint256 public epochLength = 201600; // ~28 days
    
    /// @notice íˆ¬í‘œ ì°¸ì—¬ ë³´ìƒ í’€
    uint256 public voterRewardPool;
    
    /// @notice ì œì•ˆë³„ íˆ¬í‘œ ì°¸ì—¬ì ìˆ˜
    mapping(uint256 => uint256) public proposalVoterCount;
    
    /// @notice ì œì•ˆë³„ íˆ¬í‘œ ì°¸ì—¬ ê¸°ë¡
    mapping(uint256 => mapping(address => bool)) public hasClaimedReward;
    
    /// @notice ë¶„ë…¸ í‡´ì¥ (Rage Quit) ê¸°ê°„ â€” ì œì•ˆ ì‹¤í–‰ ì „ ëŒ€ê¸°
    uint256 public rageQuitPeriod = 3 days;
    
    /// @notice ë¶„ë…¸ í‡´ì¥ ìš”ì²­
    mapping(uint256 => mapping(address => bool)) public rageQuitRequests;
    
    /// @notice ì œì•ˆ ìœ í˜•ë³„ ì„¤ì •
    enum ProposalType {
        STANDARD,           // ì¼ë°˜ ì œì•ˆ
        TREASURY_SPEND,     // íŠ¸ë ˆì €ë¦¬ ì§€ì¶œ
        PARAMETER_CHANGE,   // íŒŒë¼ë¯¸í„° ë³€ê²½
        EMERGENCY           // ê¸´ê¸‰ ì œì•ˆ
    }
    
    mapping(uint256 => ProposalType) public proposalTypes;
    
    /// @notice ì œì•ˆ ìœ í˜•ë³„ ì¿¼ëŸ¼ ë°°ìˆ˜ (basis points)
    mapping(ProposalType => uint256) public typeQuorumMultiplier;
    
    // ================================================================
    // Events â€” "ëª¨ë“  ê±°ë²„ë„ŒìŠ¤ í–‰ìœ„ëŠ” ì´ë²¤íŠ¸ë¡œ ê¸°ë¡"
    // ================================================================
    
    event VoterRewarded(
        uint256 indexed proposalId, 
        address indexed voter, 
        uint256 reward
    );
    
    event RageQuitRequested(
        uint256 indexed proposalId, 
        address indexed requester, 
        uint256 veTokenBalance
    );
    
    event TreasurySpendProposed(
        uint256 indexed proposalId, 
        uint256 amount, 
        address recipient
    );
    
    event ProposalTypeSet(
        uint256 indexed proposalId, 
        ProposalType proposalType
    );
    
    // ================================================================
    // Constructor
    // ================================================================
    
    constructor(
        IVotes _token,
        IVeToken _veToken,
        TimelockController _timelock,
        uint48 _votingDelay,
        uint32 _votingPeriod,
        uint256 _proposalThreshold,
        uint256 _quorumNumerator
    )
        Governor("MintGovernor")
        GovernorSettings(_votingDelay, _votingPeriod, _proposalThreshold)
        GovernorVotes(_token)
        GovernorVotesQuorumFraction(_quorumNumerator)
        GovernorTimelockControl(_timelock)
    {
        veToken = _veToken;
        
        // ê¸°ë³¸ ì¿¼ëŸ¼ ë°°ìˆ˜ ì„¤ì •
        // Mint: "íŠ¸ë ˆì €ë¦¬ ì§€ì¶œì€ ë” ë†’ì€ ì¿¼ëŸ¼ì´ í•„ìš”í•˜ë‹¤"
        typeQuorumMultiplier[ProposalType.STANDARD] = 10000;        // 1x
        typeQuorumMultiplier[ProposalType.TREASURY_SPEND] = 15000;  // 1.5x
        typeQuorumMultiplier[ProposalType.PARAMETER_CHANGE] = 12000; // 1.2x
        typeQuorumMultiplier[ProposalType.EMERGENCY] = 5000;        // 0.5x (ê¸´ê¸‰)
        
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(GUARDIAN_ROLE, msg.sender);
    }
    
    // ================================================================
    // Core Governance Extensions
    // ================================================================
    
    /**
     * @notice íˆ¬í‘œ ê°€ì¤‘ì¹˜ ê³„ì‚° â€” ve í† í° ê¸°ë°˜ ë¶€ìŠ¤íŠ¸
     * @dev Mint: "ì¥ê¸° ì ê¸ˆìì—ê²Œ ë” í° ëª©ì†Œë¦¬ë¥¼ ì£¼ëŠ” ê²ƒì´ í•µì‹¬"
     *
     * ê°€ì¤‘ì¹˜ = ê¸°ë³¸ íˆ¬í‘œê¶Œ * (1 + veBoost)
     * veBoost = veToken.balanceOf(account) / token.balanceOf(account)
     * ìµœëŒ€ ë¶€ìŠ¤íŠ¸: 4x
     */
    function _getVotes(
        address account,
        uint256 timepoint,
        bytes memory params
    ) internal view virtual override(Governor, GovernorVotes) returns (uint256) {
        uint256 baseVotes = super._getVotes(account, timepoint, params);
        
        if (address(veToken) == address(0)) {
            return baseVotes;
        }
        
        uint256 veBalance = veToken.balanceOf(account);
        if (veBalance == 0 || baseVotes == 0) {
            return baseVotes;
        }
        
        // ë¶€ìŠ¤íŠ¸ ê³„ì‚°: veì”ì•¡ / ê¸°ë³¸ì”ì•¡, ìµœëŒ€ 4x
        uint256 boostBps = Math.min(
            (veBalance * 10000) / baseVotes,
            40000 // ìµœëŒ€ 4x = 40000 bps
        );
        
        return baseVotes + (baseVotes * boostBps / 10000);
    }
    
    /**
     * @notice íˆ¬í‘œ ì°¸ì—¬ ë³´ìƒ ì²­êµ¬
     * @dev Mint: "ê±°ë²„ë„ŒìŠ¤ ì°¸ì—¬ëŠ” ê³µê³µì¬ë‹¤. ê³µê³µì¬ëŠ” ë³´ìƒí•´ì•¼ í•œë‹¤."
     *
     * ë³´ìƒ = voterRewardPool / proposalVoterCount[proposalId]
     * (ê· ë“± ë¶„ë°° â€” ê³ ë˜ ìš°ëŒ€ ë°©ì§€)
     */
    function claimVoterReward(uint256 proposalId) external {
        require(
            state(proposalId) == ProposalState.Executed ||
            state(proposalId) == ProposalState.Defeated,
            "MintGovernor: proposal not finalized"
        );
        require(
            hasVoted(proposalId, msg.sender),
            "MintGovernor: did not vote"
        );
        require(
            !hasClaimedReward[proposalId][msg.sender],
            "MintGovernor: already claimed"
        );
        
        uint256 voterCount = proposalVoterCount[proposalId];
        require(voterCount > 0, "MintGovernor: no voters");
        
        // ì œì•ˆë‹¹ ë³´ìƒ í’€ì˜ ì¼ì • ë¹„ìœ¨ ë°°ë¶„
        uint256 rewardPerVoter = voterRewardPool / (voterCount * 100); // 1% per proposal
        
        hasClaimedReward[proposalId][msg.sender] = true;
        voterRewardPool -= rewardPerVoter;
        
        // ë³´ìƒ ì „ì†¡ ë¡œì§ (ì‹¤ì œ êµ¬í˜„ ì‹œ í† í° ì „ì†¡)
        emit VoterRewarded(proposalId, msg.sender, rewardPerVoter);
    }
    
    /**
     * @notice ë¶„ë…¸ í‡´ì¥ ìš”ì²­ â€” ì†Œìˆ˜ì ë³´í˜¸ ë©”ì»¤ë‹ˆì¦˜
     * @dev Mint: "51% ê³µê²©ìœ¼ë¡œë¶€í„° 49%ë¥¼ ë³´í˜¸í•˜ëŠ” ì•ˆì „ì¥ì¹˜.
     *           ì†Œìˆ˜ ë³´ìœ ìê°€ ë¶ˆë¦¬í•œ ì œì•ˆì— ëŒ€í•´ ìì‚°ì„ íšŒìˆ˜í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤."
     */
    function requestRageQuit(uint256 proposalId) external {
        require(
            state(proposalId) == ProposalState.Succeeded,
            "MintGovernor: proposal not succeeded"
        );
        require(
            hasVoted(proposalId, msg.sender),
            "MintGovernor: must have voted"
        );
        // ë°˜ëŒ€í‘œë¥¼ í–‰ì‚¬í•œ ì‚¬ëŒë§Œ ë¶„ë…¸ í‡´ì¥ ê°€ëŠ¥
        // (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” íˆ¬í‘œ ë°©í–¥ í™•ì¸ í•„ìš”)
        
        rageQuitRequests[proposalId][msg.sender] = true;
        
        emit RageQuitRequested(
            proposalId, 
            msg.sender, 
            veToken.balanceOf(msg.sender)
        );
    }
    
    /**
     * @notice íŠ¸ë ˆì €ë¦¬ ì§€ì¶œ í•œë„ í™•ì¸
     * @dev Mint: "ë¬´í•œí•œ íŠ¸ë ˆì €ë¦¬ ì ‘ê·¼ì€ DAOì˜ ì£½ìŒì´ë‹¤.
     *           ì—í¬í¬ë³„ ì§€ì¶œ í•œë„ê°€ ìˆì–´ì•¼ ì¥ê¸° ìƒì¡´ì´ ê°€ëŠ¥í•˜ë‹¤."
     */
    function checkTreasurySpendLimit(uint256 amount) public view returns (bool) {
        if (address(treasury) == address(0)) return true;
        
        uint256 currentEpoch = block.number / epochLength;
        uint256 epochSpent = treasury.epochSpent(currentEpoch);
        uint256 treasuryBalance = treasury.balance();
        uint256 epochLimit = (treasuryBalance * treasurySpendLimitBps) / 10000;
        
        return (epochSpent + amount) <= epochLimit;
    }
    
    // ================================================================
    // Admin Functions â€” "íŒŒë¼ë¯¸í„° ë³€ê²½ë„ ê±°ë²„ë„ŒìŠ¤ë¥¼ í†µí•´"
    // ================================================================
    
    function setTreasurySpendLimit(uint256 newLimitBps) 
        external 
        onlyGovernance 
    {
        require(newLimitBps <= 5000, "MintGovernor: max 50% per epoch");
        treasurySpendLimitBps = newLimitBps;
    }
    
    function setRageQuitPeriod(uint256 newPeriod) 
        external 
        onlyGovernance 
    {
        require(newPeriod >= 1 days && newPeriod <= 14 days, 
                "MintGovernor: invalid period");
        rageQuitPeriod = newPeriod;
    }
    
    function fundVoterRewardPool() external payable {
        voterRewardPool += msg.value;
    }
    
    /**
     * @notice ê¸´ê¸‰ ê°€ë””ì–¸ ê¸°ëŠ¥ â€” ì•…ì˜ì  ì œì•ˆ ê¸´ê¸‰ ì·¨ì†Œ
     * @dev Mint: "íƒˆì¤‘ì•™í™”ì™€ ì•ˆì „ ì‚¬ì´ì˜ ê· í˜•. 
     *           ê°€ë””ì–¸ ê¶Œí•œì€ ì ì§„ì ìœ¼ë¡œ ì œê±°í•´ì•¼ í•œë‹¤."
     */
    function emergencyCancel(uint256 proposalId) 
        external 
        onlyRole(GUARDIAN_ROLE) 
    {
        // ê¸´ê¸‰ ì·¨ì†Œ ë¡œì§ (ì‹¤ì œ êµ¬í˜„ ì‹œ Governorì˜ cancel í˜¸ì¶œ)
        _cancel(
            new address[](0),
            new uint256[](0),
            new bytes[](0),
            keccak256(abi.encode(proposalId))
        );
    }
    
    // ================================================================
    // Required Overrides
    // ================================================================
    
    function votingDelay()
        public view override(Governor, GovernorSettings)
        returns (uint256)
    {
        return super.votingDelay();
    }

    function votingPeriod()
        public view override(Governor, GovernorSettings)
        returns (uint256)
    {
        return super.votingPeriod();
    }

    function quorum(uint256 blockNumber)
        public view override(Governor, GovernorVotesQuorumFraction)
        returns (uint256)
    {
        return super.quorum(blockNumber);
    }

    function state(uint256 proposalId)
        public view override(Governor, GovernorTimelockControl)
        returns (ProposalState)
    {
        return super.state(proposalId);
    }

    function proposalNeedsQueuing(uint256 proposalId)
        public view override(Governor, GovernorTimelockControl)
        returns (bool)
    {
        return super.proposalNeedsQueuing(proposalId);
    }

    function proposalThreshold()
        public view override(Governor, GovernorSettings)
        returns (uint256)
    {
        return super.proposalThreshold();
    }

    function _queueOperations(
        uint256 proposalId,
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) internal override(Governor, GovernorTimelockControl) returns (uint48) {
        return super._queueOperations(
            proposalId, targets, values, calldatas, descriptionHash
        );
    }

    function _executeOperations(
        uint256 proposalId,
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) internal override(Governor, GovernorTimelockControl) {
        super._executeOperations(
            proposalId, targets, values, calldatas, descriptionHash
        );
    }

    function _cancel(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) internal override(Governor, GovernorTimelockControl) returns (uint256) {
        return super._cancel(targets, values, calldatas, descriptionHash);
    }

    function _executor()
        internal view override(Governor, GovernorTimelockControl)
        returns (address)
    {
        return super._executor();
    }
    
    function supportsInterface(bytes4 interfaceId)
        public view override(Governor, GovernorTimelockControl, AccessControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}


/**
 * @title MintVeToken â€” Vote-Escrowed í† í° êµ¬í˜„
 * @author Mint (Jung Subin) / F1-24
 * @notice Curveì˜ veCRV ëª¨ë¸ì„ ì°¸ê³ í•œ íˆ¬í‘œ ì—ìŠ¤í¬ë¡œ í† í°
 *
 * Mint: "ì‹œê°„ì„ í™”íë¡œ ë³€í™˜í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜.
 *        ì˜¤ë˜ ì ê¸€ìˆ˜ë¡ ë” í° ê¶Œí•œì„ ì–»ëŠ”ë‹¤."
 */
contract MintVeToken is IVeToken {
    
    struct Lock {
        uint256 amount;        // ì ê¸´ í† í°ëŸ‰
        uint256 end;           // ì ê¸ˆ ì¢…ë£Œ ì‹œì  (Unix timestamp)
        uint256 startTime;     // ì ê¸ˆ ì‹œì‘ ì‹œì 
        uint256 maxDuration;   // ìµœëŒ€ ì ê¸ˆ ê¸°ê°„ (ì´ˆ)
    }
    
    /// @notice ê¸°ë³¸ í† í° (ì ê¸€ ëŒ€ìƒ)
    IERC20 public immutable token;
    
    /// @notice ìµœëŒ€ ì ê¸ˆ ê¸°ê°„: 4ë…„
    uint256 public constant MAX_LOCK_DURATION = 4 * 365 days;
    
    /// @notice ìµœì†Œ ì ê¸ˆ ê¸°ê°„: 1ì£¼
    uint256 public constant MIN_LOCK_DURATION = 7 days;
    
    /// @notice ì‚¬ìš©ìë³„ ì ê¸ˆ ì •ë³´
    mapping(address => Lock) public locks;
    
    /// @notice ì´ ì ê¸´ í† í°ëŸ‰
    uint256 public totalLocked;
    
    // Events
    event Locked(address indexed user, uint256 amount, uint256 duration, uint256 end);
    event Unlocked(address indexed user, uint256 amount);
    event Extended(address indexed user, uint256 newEnd);
    event Increased(address indexed user, uint256 additionalAmount);
    
    constructor(IERC20 _token) {
        token = _token;
    }
    
    /**
     * @notice í† í° ì ê¸ˆ â€” veToken íšë“
     * @param amount ì ê¸€ í† í° ìˆ˜ëŸ‰
     * @param duration ì ê¸ˆ ê¸°ê°„ (ì´ˆ)
     *
     * Mint: "ì ê¸ˆì€ ì‹ ë¢°ì˜ í‘œí˜„ì´ë‹¤.
     *        í”„ë¡œí† ì½œì— ëŒ€í•œ ì¥ê¸°ì  í™•ì‹ ì„ ì˜¨ì²´ì¸ìœ¼ë¡œ ì¦ëª…í•œë‹¤."
     */
    function lock(uint256 amount, uint256 duration) external {
        require(amount > 0, "MintVe: zero amount");
        require(duration >= MIN_LOCK_DURATION, "MintVe: too short");
        require(duration <= MAX_LOCK_DURATION, "MintVe: too long");
        require(locks[msg.sender].amount == 0, "MintVe: already locked");
        
        uint256 end = block.timestamp + duration;
        
        locks[msg.sender] = Lock({
            amount: amount,
            end: end,
            startTime: block.timestamp,
            maxDuration: MAX_LOCK_DURATION
        });
        
        totalLocked += amount;
        
        require(
            token.transferFrom(msg.sender, address(this), amount),
            "MintVe: transfer failed"
        );
        
        emit Locked(msg.sender, amount, duration, end);
    }
    
    /**
     * @notice ì ê¸ˆ í•´ì œ â€” ë§Œë£Œ í›„ í† í° íšŒìˆ˜
     */
    function unlock() external {
        Lock storage userLock = locks[msg.sender];
        require(userLock.amount > 0, "MintVe: no lock");
        require(block.timestamp >= userLock.end, "MintVe: still locked");
        
        uint256 amount = userLock.amount;
        totalLocked -= amount;
        delete locks[msg.sender];
        
        require(
            token.transfer(msg.sender, amount),
            "MintVe: transfer failed"
        );
        
        emit Unlocked(msg.sender, amount);
    }
    
    /**
     * @notice ì ê¸ˆ ê¸°ê°„ ì—°ì¥
     */
    function extendLock(uint256 additionalDuration) external {
        Lock storage userLock = locks[msg.sender];
        require(userLock.amount > 0, "MintVe: no lock");
        
        uint256 newEnd = userLock.end + additionalDuration;
        require(
            newEnd <= block.timestamp + MAX_LOCK_DURATION,
            "MintVe: exceeds max duration"
        );
        
        userLock.end = newEnd;
        emit Extended(msg.sender, newEnd);
    }
    
    /**
     * @notice ì ê¸ˆëŸ‰ ì¦ê°€
     */
    function increaseLock(uint256 additionalAmount) external {
        Lock storage userLock = locks[msg.sender];
        require(userLock.amount > 0, "MintVe: no lock");
        require(block.timestamp < userLock.end, "MintVe: expired");
        
        userLock.amount += additionalAmount;
        totalLocked += additionalAmount;
        
        require(
            token.transferFrom(msg.sender, address(this), additionalAmount),
            "MintVe: transfer failed"
        );
        
        emit Increased(msg.sender, additionalAmount);
    }
    
    /**
     * @notice veToken ì”ì•¡ ì¡°íšŒ â€” ì‹œê°„ ê°€ì¤‘ ì„ í˜• ê°ì†Œ
     * @dev veBalance = amount * (timeRemaining / maxDuration)
     *
     * Mint: "veToken ì”ì•¡ì€ ì‹œê°„ì— ë”°ë¼ ê°ì†Œí•œë‹¤.
     *        ì´ê²ƒì´ ì§€ì†ì ì¸ ì¬ì ê¸ˆ ì¸ì„¼í‹°ë¸Œë¥¼ ë§Œë“ ë‹¤."
     */
    function balanceOf(address account) external view override returns (uint256) {
        Lock storage userLock = locks[account];
        if (userLock.amount == 0 || block.timestamp >= userLock.end) {
            return 0;
        }
        
        uint256 timeRemaining = userLock.end - block.timestamp;
        return (userLock.amount * timeRemaining) / MAX_LOCK_DURATION;
    }
    
    /**
     * @notice ì ê¸ˆ ì¢…ë£Œ ì‹œì  ì¡°íšŒ
     */
    function lockEnd(address account) external view override returns (uint256) {
        return locks[account].end;
    }
    
    /**
     * @notice ì´ veToken ê³µê¸‰ëŸ‰ (ê·¼ì‚¬ì¹˜)
     */
    function totalSupply() external view override returns (uint256) {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì²´í¬í¬ì¸íŠ¸ ê¸°ë°˜ ì •í™•í•œ ê³„ì‚° í•„ìš”
        // ì—¬ê¸°ì„œëŠ” ê°„ë‹¨í•œ ê·¼ì‚¬ì¹˜ ì‚¬ìš©
        return totalLocked / 2; // í‰ê·  ì”ì—¬ ê¸°ê°„ ê°€ì •
    }
}

/// @dev ì¸í„°í˜ì´ìŠ¤ ì°¸ì¡°ìš©
interface IERC20 {
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}
```

### 3.4 ì—ì´ì „íŠ¸ ê¸°ë°˜ ì‹œë®¬ë ˆì´ì…˜ (Agent-Based Modeling)

```python
"""
mint_abm_simulation.py
=======================
Agent-Based Modelì„ ì‚¬ìš©í•œ í† í° ìƒíƒœê³„ ì‹œë®¬ë ˆì´ì…˜.

Mint: "ìˆ˜í•™ì  ëª¨ë¸ì€ ê· í˜•ì ì„ ì°¾ì•„ì£¼ì§€ë§Œ,
      ì—ì´ì „íŠ¸ ê¸°ë°˜ ëª¨ë¸ì€ ê·¸ ê· í˜•ì— ë„ë‹¬í•˜ëŠ” ê²½ë¡œë¥¼ ë³´ì—¬ì¤€ë‹¤."

Mesa í”„ë ˆì„ì›Œí¬ë¥¼ ì‚¬ìš©í•œ ë‹¤ì¤‘ ì—ì´ì „íŠ¸ ì‹œë®¬ë ˆì´ì…˜.

Author: Mint (Jung Subin) / F1-24
"""

import numpy as np
from typing import Dict, List, Optional
from dataclasses import dataclass, field
from enum import Enum, auto
import random


class AgentType(Enum):
    """ì—ì´ì „íŠ¸ ìœ í˜• â€” í† í° ìƒíƒœê³„ì˜ ì°¸ì—¬ì ìœ í˜•"""
    WHALE = auto()            # ê³ ë˜ â€” ëŒ€ê·œëª¨ ë³´ìœ , ë‚®ì€ ë¹ˆë„ ê±°ë˜
    RETAIL = auto()           # ì†Œë§¤ íˆ¬ìì â€” ì†Œê·œëª¨, ë†’ì€ ë³€ë™ì„±
    YIELD_FARMER = auto()     # ìˆ˜í™• ë†ë¶€ â€” ìµœê³  APY ì¶”êµ¬, ìš©ë³‘ì 
    LONG_TERM_HOLDER = auto() # ì¥ê¸° ë³´ìœ ì â€” ë§¤ìˆ˜ í›„ ë³´ìœ , ìŠ¤í…Œì´í‚¹
    ARBITRAGEUR = auto()      # ì°¨ìµê±°ë˜ì â€” ê°€ê²© ì°¨ì´ í™œìš©
    GOVERNANCE_ACTIVE = auto() # ê±°ë²„ë„ŒìŠ¤ ì ê·¹ ì°¸ì—¬ì
    BOT = auto()              # ë´‡ â€” ìë™í™”ëœ ì „ëµ ì‹¤í–‰


@dataclass
class TokenAgent:
    """
    í† í° ìƒíƒœê³„ ì—ì´ì „íŠ¸.
    
    ê° ì—ì´ì „íŠ¸ëŠ” ê³ ìœ í•œ ì „ëµê³¼ ì„ í˜¸ë„ë¥¼ ê°€ì§„ë‹¤.
    Mint: "ì‹¤ì œ ì‹œì¥ì€ ì™„ì „íˆ í•©ë¦¬ì ì¸ ì°¸ì—¬ìë¡œ êµ¬ì„±ë˜ì§€ ì•ŠëŠ”ë‹¤.
          ë‹¤ì–‘í•œ í–‰íƒœì  í¸í–¥ì„ ëª¨ë¸ì— ë°˜ì˜í•´ì•¼ í•œë‹¤."
    """
    agent_id: int
    agent_type: AgentType
    token_balance: float
    stablecoin_balance: float
    staked_amount: float = 0.0
    ve_locked_amount: float = 0.0
    ve_lock_end: int = 0
    
    # í–‰ë™ íŒŒë¼ë¯¸í„°
    risk_tolerance: float = 0.5       # 0=ê·¹ë„ ë³´ìˆ˜ì , 1=ê·¹ë„ ê³µê²©ì 
    time_horizon: int = 365           # íˆ¬ì ê¸°ê°„ (ì¼)
    sell_threshold: float = 2.0       # ë§¤ë„ ì‹œì‘ ìˆ˜ìµë¥  (2x = 100% ìˆ˜ìµ)
    buy_threshold: float = 0.8        # ë§¤ìˆ˜ ì‹œì‘ í•˜ë½ë¥  (20% í• ì¸)
    governance_participation: float = 0.5  # ê±°ë²„ë„ŒìŠ¤ ì°¸ì—¬ í™•ë¥ 
    
    # ì¶”ì  ë³€ìˆ˜
    entry_price: float = 0.0
    total_pnl: float = 0.0
    trade_count: int = 0
    votes_cast: int = 0
    
    def decide_action(
        self, 
        current_price: float, 
        staking_apy: float,
        governance_proposals: int,
        market_sentiment: float  # -1 (ê·¹ë„ ê³µí¬) ~ 1 (ê·¹ë„ íƒìš•)
    ) -> Dict:
        """
        ì—ì´ì „íŠ¸ì˜ í–‰ë™ ê²°ì •.
        
        Mint: "ê° ì—ì´ì „íŠ¸ ìœ í˜•ì€ ê°™ì€ ì •ë³´ë¥¼ ë‹¤ë¥´ê²Œ í•´ì„í•œë‹¤.
              ì´ê²ƒì´ ì‹œì¥ì„ ë§Œë“ ë‹¤."
        """
        action = {'type': 'hold', 'amount': 0}
        
        if self.agent_type == AgentType.WHALE:
            action = self._whale_strategy(current_price, market_sentiment)
        elif self.agent_type == AgentType.RETAIL:
            action = self._retail_strategy(current_price, market_sentiment)
        elif self.agent_type == AgentType.YIELD_FARMER:
            action = self._yield_farmer_strategy(staking_apy)
        elif self.agent_type == AgentType.LONG_TERM_HOLDER:
            action = self._hodler_strategy(current_price)
        elif self.agent_type == AgentType.GOVERNANCE_ACTIVE:
            action = self._governance_strategy(
                current_price, staking_apy, governance_proposals
            )
        elif self.agent_type == AgentType.ARBITRAGEUR:
            action = self._arbitrage_strategy(current_price)
        
        return action
    
    def _whale_strategy(self, price: float, sentiment: float) -> Dict:
        """
        ê³ ë˜ ì „ëµ: ì‹œì¥ ì‹¬ë¦¬ì˜ ë°˜ëŒ€ë¡œ í–‰ë™ (ì—­ì¶”ì„¸)
        
        Mint: "ê³ ë˜ëŠ” ëŒ€ì¤‘ê³¼ ë°˜ëŒ€ë¡œ ì›€ì§ì¸ë‹¤.
              ê³µí¬ì— ë§¤ìˆ˜í•˜ê³ , íƒìš•ì— ë§¤ë„í•œë‹¤."
        """
        if sentiment < -0.5 and self.stablecoin_balance > 0:
            # ê·¹ë„ì˜ ê³µí¬ â†’ ëŒ€ê·œëª¨ ë§¤ìˆ˜
            buy_amount = self.stablecoin_balance * 0.3
            return {'type': 'buy', 'amount': buy_amount / price}
        elif sentiment > 0.7 and self.token_balance > 0:
            # ê·¹ë„ì˜ íƒìš• â†’ ì ì§„ì  ë§¤ë„
            sell_amount = self.token_balance * 0.1
            return {'type': 'sell', 'amount': sell_amount}
        
        # ìŠ¤í…Œì´í‚¹ ì„ í˜¸
        if self.token_balance > 0 and self.staked_amount < self.token_balance * 0.5:
            stake_amount = (self.token_balance * 0.5) - self.staked_amount
            return {'type': 'stake', 'amount': stake_amount}
        
        return {'type': 'hold', 'amount': 0}
    
    def _retail_strategy(self, price: float, sentiment: float) -> Dict:
        """
        ì†Œë§¤ íˆ¬ìì ì „ëµ: ì¶”ì„¸ ì¶”ì¢… (ëª¨ë©˜í…€)
        
        Mint: "ì†Œë§¤ íˆ¬ììëŠ” ë‰´ìŠ¤ì™€ ì†Œì…œ ë¯¸ë””ì–´ì— ë°˜ì‘í•œë‹¤.
              FOMOì™€ FUDê°€ í–‰ë™ì„ ì§€ë°°í•œë‹¤."
        """
        noise = random.gauss(0, 0.2)  # í–‰ë™ì  í¸í–¥
        adjusted_sentiment = sentiment + noise
        
        if adjusted_sentiment > 0.3 and self.stablecoin_balance > 0:
            # FOMO â€” ë§¤ìˆ˜
            buy_pct = min(0.5, adjusted_sentiment * self.risk_tolerance)
            buy_amount = self.stablecoin_balance * buy_pct
            return {'type': 'buy', 'amount': buy_amount / price}
        elif adjusted_sentiment < -0.3 and self.token_balance > 0:
            # FUD â€” íŒ¨ë‹‰ ë§¤ë„
            sell_pct = min(0.7, abs(adjusted_sentiment) * (1 + self.risk_tolerance))
            sell_amount = self.token_balance * sell_pct
            return {'type': 'sell', 'amount': sell_amount}
        
        return {'type': 'hold', 'amount': 0}
    
    def _yield_farmer_strategy(self, staking_apy: float) -> Dict:
        """
        ìˆ˜í™• ë†ë¶€ ì „ëµ: APY ìµœì í™”
        
        Mint: "ìˆ˜í™• ë†ë¶€ëŠ” í”„ë¡œí† ì½œì˜ ìš©ë³‘ì´ë‹¤.
              ë” ë†’ì€ APYê°€ ìˆìœ¼ë©´ ìë³¸ì„ ì´ë™í•œë‹¤.
              ì´ë“¤ì„ ë¬¶ì–´ë‘ë ¤ë©´ ve ì ê¸ˆì´ í•„ìš”í•˜ë‹¤."
        """
        alternative_apy = random.uniform(0.05, 0.30)  # ë‹¤ë¥¸ í”„ë¡œí† ì½œ APY
        
        if staking_apy > alternative_apy * 1.2:  # 20% ì´ìƒ ë†’ìœ¼ë©´ ì§„ì…
            if self.token_balance > 0 and self.staked_amount == 0:
                return {'type': 'stake', 'amount': self.token_balance * 0.9}
        elif staking_apy < alternative_apy * 0.8:  # 20% ì´ìƒ ë‚®ìœ¼ë©´ ì´íƒˆ
            if self.staked_amount > 0:
                return {'type': 'unstake_and_sell', 'amount': self.staked_amount}
        
        return {'type': 'hold', 'amount': 0}
    
    def _hodler_strategy(self, price: float) -> Dict:
        """
        ì¥ê¸° ë³´ìœ ì ì „ëµ: DCA + ìŠ¤í…Œì´í‚¹
        
        Mint: "ì´ë“¤ì´ í”„ë¡œí† ì½œì˜ ë¼ˆëŒ€ë‹¤.
              ê°€ê²©ì— ê´€ê³„ì—†ì´ ê¾¸ì¤€íˆ ì¶•ì í•˜ê³  ìŠ¤í…Œì´í‚¹í•œë‹¤."
        """
        # ë§¤ì›” ì¼ì •ëŸ‰ DCA ë§¤ìˆ˜
        if self.stablecoin_balance > 100:
            monthly_dca = min(self.stablecoin_balance * 0.1, 1000)
            return {'type': 'buy_and_stake', 'amount': monthly_dca / price}
        
        # ë³´ìœ  ì¤‘ì¸ í† í° ìŠ¤í…Œì´í‚¹
        if self.token_balance > 0 and self.staked_amount < self.token_balance * 0.8:
            return {'type': 'stake', 'amount': self.token_balance * 0.8 - self.staked_amount}
        
        return {'type': 'hold', 'amount': 0}
    
    def _governance_strategy(
        self, price: float, apy: float, proposals: int
    ) -> Dict:
        """
        ê±°ë²„ë„ŒìŠ¤ ì ê·¹ ì°¸ì—¬ì ì „ëµ
        
        Mint: "ì§„ì •í•œ ê±°ë²„ë„ŒìŠ¤ ì°¸ì—¬ìëŠ” ìˆ˜ìµë³´ë‹¤ í”„ë¡œí† ì½œì˜ ë°©í–¥ì— ê´€ì‹¬ì´ ìˆë‹¤.
              ì´ë“¤ì—ê²Œ ve ì ê¸ˆ ì¸ì„¼í‹°ë¸Œê°€ ê°€ì¥ íš¨ê³¼ì ì´ë‹¤."
        """
        # ve ì ê¸ˆ ì„ í˜¸
        if self.token_balance > 0 and self.ve_locked_amount == 0:
            lock_amount = self.token_balance * 0.7
            return {'type': 've_lock', 'amount': lock_amount, 'duration': 365 * 2}
        
        # í™œì„± ì œì•ˆì´ ìˆìœ¼ë©´ íˆ¬í‘œ ì°¸ì—¬
        if proposals > 0 and random.random() < self.governance_participation:
            return {'type': 'vote', 'amount': 0, 'proposals': proposals}
        
        return {'type': 'hold', 'amount': 0}
    
    def _arbitrage_strategy(self, price: float) -> Dict:
        """
        ì°¨ìµê±°ë˜ì ì „ëµ
        
        Mint: "ì°¨ìµê±°ë˜ìëŠ” ì‹œì¥ì˜ íš¨ìœ¨ì„±ì„ ë†’ì´ëŠ” ì—­í• ì„ í•œë‹¤.
              ì´ë“¤ì˜ ì¡´ì¬ê°€ ê°€ê²© ë°œê²¬ ë©”ì»¤ë‹ˆì¦˜ì„ ê°•í™”í•œë‹¤."
        """
        # DEX/CEX ê°€ê²© ì°¨ì´ ì‹œë®¬ë ˆì´ì…˜
        dex_price = price * random.uniform(0.98, 1.02)
        cex_price = price * random.uniform(0.98, 1.02)
        
        spread = abs(dex_price - cex_price) / price
        if spread > 0.01:  # 1% ì´ìƒ ìŠ¤í”„ë ˆë“œ
            arb_size = min(self.token_balance * 0.5, self.stablecoin_balance / price * 0.5)
            return {
                'type': 'arbitrage',
                'amount': arb_size,
                'spread': spread,
                'direction': 'buy_dex' if dex_price < cex_price else 'buy_cex'
            }
        
        return {'type': 'hold', 'amount': 0}


@dataclass
class TokenEcosystemSimulation:
    """
    í† í° ìƒíƒœê³„ ABM ì‹œë®¬ë ˆì´ì…˜.
    
    Mint: "ì´ ì‹œë®¬ë ˆì´ì…˜ì˜ ê°€ì¹˜ëŠ” ì •í™•í•œ ì˜ˆì¸¡ì´ ì•„ë‹ˆë¼,
          ë‹¤ì–‘í•œ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ ì‹œìŠ¤í…œì˜ ë™ì  í–‰íƒœë¥¼ ì´í•´í•˜ëŠ” ê²ƒì´ë‹¤."
    """
    
    # ì‹œë®¬ë ˆì´ì…˜ íŒŒë¼ë¯¸í„°
    num_agents: int = 1000
    initial_token_price: float = 1.0
    total_token_supply: int = 1_000_000_000
    simulation_days: int = 365
    
    # ì—ì´ì „íŠ¸ êµ¬ì„± ë¹„ìœ¨
    agent_distribution: Dict = field(default_factory=lambda: {
        AgentType.WHALE: 0.02,
        AgentType.RETAIL: 0.50,
        AgentType.YIELD_FARMER: 0.15,
        AgentType.LONG_TERM_HOLDER: 0.15,
        AgentType.ARBITRAGEUR: 0.08,
        AgentType.GOVERNANCE_ACTIVE: 0.07,
        AgentType.BOT: 0.03,
    })
    
    # ìƒíƒœ
    agents: List[TokenAgent] = field(default_factory=list)
    price_history: List[float] = field(default_factory=list)
    volume_history: List[float] = field(default_factory=list)
    staking_ratio_history: List[float] = field(default_factory=list)
    governance_participation_history: List[float] = field(default_factory=list)
    
    def initialize(self):
        """ì—ì´ì „íŠ¸ ìƒì„± ë° ì´ˆê¸° í† í° ë¶„ë°°"""
        self.agents = []
        agent_id = 0
        
        for agent_type, pct in self.agent_distribution.items():
            count = int(self.num_agents * pct)
            
            for _ in range(count):
                # ì—ì´ì „íŠ¸ ìœ í˜•ì— ë”°ë¥¸ ì´ˆê¸° ìë³¸ ë°°ë¶„
                if agent_type == AgentType.WHALE:
                    token_balance = random.uniform(1_000_000, 50_000_000)
                    stable_balance = random.uniform(500_000, 10_000_000)
                    risk_tol = random.uniform(0.3, 0.6)
                elif agent_type == AgentType.RETAIL:
                    token_balance = random.uniform(100, 50_000)
                    stable_balance = random.uniform(100, 10_000)
                    risk_tol = random.uniform(0.4, 0.9)
                elif agent_type == AgentType.YIELD_FARMER:
                    token_balance = random.uniform(10_000, 500_000)
                    stable_balance = random.uniform(50_000, 1_000_000)
                    risk_tol = random.uniform(0.6, 0.9)
                elif agent_type == AgentType.LONG_TERM_HOLDER:
                    token_balance = random.uniform(5_000, 200_000)
                    stable_balance = random.uniform(1_000, 50_000)
                    risk_tol = random.uniform(0.2, 0.5)
                elif agent_type == AgentType.GOVERNANCE_ACTIVE:
                    token_balance = random.uniform(50_000, 2_000_000)
                    stable_balance = random.uniform(10_000, 100_000)
                    risk_tol = random.uniform(0.3, 0.6)
                else:
                    token_balance = random.uniform(1_000, 100_000)
                    stable_balance = random.uniform(5_000, 200_000)
                    risk_tol = random.uniform(0.5, 0.8)
                
                agent = TokenAgent(
                    agent_id=agent_id,
                    agent_type=agent_type,
                    token_balance=token_balance,
                    stablecoin_balance=stable_balance,
                    risk_tolerance=risk_tol,
                    entry_price=self.initial_token_price
                )
                self.agents.append(agent)
                agent_id += 1
        
        self.price_history = [self.initial_token_price]
        print(f"ğŸª™ Initialized {len(self.agents)} agents")
        for agent_type, pct in self.agent_distribution.items():
            count = sum(1 for a in self.agents if a.agent_type == agent_type)
            print(f"   {agent_type.name}: {count} agents ({pct*100:.0f}%)")
    
    def step(self, day: int):
        """í•˜ë£¨ ì‹œë®¬ë ˆì´ì…˜ ìŠ¤í…"""
        current_price = self.price_history[-1]
        
        # ì‹œì¥ ì‹¬ë¦¬ ê³„ì‚° (ìµœê·¼ ê°€ê²© ë³€ë™ ê¸°ë°˜)
        if len(self.price_history) >= 7:
            weekly_return = (current_price / self.price_history[-7]) - 1
            sentiment = np.tanh(weekly_return * 10)  # -1 ~ 1ë¡œ ì •ê·œí™”
        else:
            sentiment = 0.0
        
        # ìŠ¤í…Œì´í‚¹ APY (í˜„ì¬ ìŠ¤í…Œì´í‚¹ ë¹„ìœ¨ ê¸°ë°˜)
        total_staked = sum(a.staked_amount + a.ve_locked_amount for a in self.agents)
        total_tokens = sum(a.token_balance + a.staked_amount + a.ve_locked_amount 
                          for a in self.agents)
        staking_ratio = total_staked / total_tokens if total_tokens > 0 else 0
        staking_apy = 0.08 * (0.45 / max(staking_ratio, 0.01))  # ì—­ë¹„ë¡€ APY
        staking_apy = min(staking_apy, 0.25)
        
        # ê° ì—ì´ì „íŠ¸ í–‰ë™ ê²°ì • ë° ì‹¤í–‰
        buy_volume = 0
        sell_volume = 0
        
        random.shuffle(self.agents)  # ìˆœì„œ í¸í–¥ ë°©ì§€
        
        for agent in self.agents:
            action = agent.decide_action(
                current_price, staking_apy, 
                governance_proposals=random.randint(0, 3),
                market_sentiment=sentiment
            )
            
            if action['type'] in ['buy', 'buy_and_stake']:
                buy_volume += action['amount'] * current_price
                agent.token_balance += action['amount']
                agent.stablecoin_balance -= action['amount'] * current_price
                if action['type'] == 'buy_and_stake':
                    agent.staked_amount += action['amount']
                    agent.token_balance -= action['amount']
            
            elif action['type'] == 'sell':
                sell_volume += action['amount'] * current_price
                agent.stablecoin_balance += action['amount'] * current_price
                agent.token_balance -= action['amount']
            
            elif action['type'] == 'stake':
                agent.staked_amount += action['amount']
                agent.token_balance -= action['amount']
            
            elif action['type'] == 'unstake_and_sell':
                agent.staked_amount -= action['amount']
                sell_volume += action['amount'] * current_price
                agent.stablecoin_balance += action['amount'] * current_price
            
            elif action['type'] == 've_lock':
                agent.ve_locked_amount += action['amount']
                agent.token_balance -= action['amount']
            
            elif action['type'] == 'vote':
                agent.votes_cast += 1
        
        # ê°€ê²© ì—…ë°ì´íŠ¸ (ë‹¨ìˆœ ìˆ˜ìš”-ê³µê¸‰ ëª¨ë¸)
        net_flow = buy_volume - sell_volume
        total_volume = buy_volume + sell_volume
        if total_volume > 0:
            price_impact = (net_flow / total_volume) * 0.1  # 10% max impact
            new_price = current_price * (1 + price_impact)
            # ëœë¤ ë…¸ì´ì¦ˆ ì¶”ê°€
            noise = random.gauss(0, 0.02)
            new_price *= (1 + noise)
            new_price = max(new_price, 0.001)  # ìµœì†Œ ê°€ê²©
        else:
            new_price = current_price
        
        self.price_history.append(new_price)
        self.volume_history.append(total_volume)
        self.staking_ratio_history.append(staking_ratio)
        
        # ê±°ë²„ë„ŒìŠ¤ ì°¸ì—¬ìœ¨
        total_voters = sum(1 for a in self.agents if a.votes_cast > 0)
        gov_participation = total_voters / len(self.agents)
        self.governance_participation_history.append(gov_participation)
    
    def run(self):
        """ì „ì²´ ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰"""
        print(f"\nğŸª™ Running Token Ecosystem Simulation...")
        print(f"   Days: {self.simulation_days}")
        print(f"   Initial Price: ${self.initial_token_price:.4f}")
        
        self.initialize()
        
        for day in range(1, self.simulation_days + 1):
            self.step(day)
            
            if day % 30 == 0:
                price = self.price_history[-1]
                staking = self.staking_ratio_history[-1]
                print(f"   Day {day:>3}: Price=${price:.4f}, "
                      f"Staking={staking:.1%}, "
                      f"Vol=${self.volume_history[-1]:,.0f}")
        
        print(f"\nâœ… Simulation Complete!")
        print(f"   Final Price: ${self.price_history[-1]:.4f}")
        print(f"   Price Change: {(self.price_history[-1]/self.initial_token_price - 1)*100:+.1f}%")
        print(f"   Final Staking Ratio: {self.staking_ratio_history[-1]:.1%}")
        print(f"   Avg Daily Volume: ${np.mean(self.volume_history):,.0f}")


if __name__ == "__main__":
    sim = TokenEcosystemSimulation(
        num_agents=500,
        initial_token_price=0.10,
        simulation_days=365
    )
    sim.run()
```

---

## 4. ë„êµ¬ ì²´ì¸ (Toolchain)

```yaml
# mint_toolchain.yaml
# ===================
# Mint's Tokenomics & Governance Engineering Toolchain
# "ë„êµ¬ëŠ” ì‚¬ê³ ë¥¼ í™•ì¥í•œë‹¤. ì˜¬ë°”ë¥¸ ë„êµ¬ ì„ íƒì´ ë°˜ì€ ë¨¹ê³  ë“¤ì–´ê°„ë‹¤." â€” Mint

# ================================================================
# 1. Agent-Based Modeling (ABM) â€” ì—ì´ì „íŠ¸ ê¸°ë°˜ ì‹œë®¬ë ˆì´ì…˜
# ================================================================
agent_based_modeling:
  primary:
    name: "cadCAD"
    version: "0.5.3+"
    purpose: "í† í° ì‹œìŠ¤í…œ ë™ì  ì‹œë®¬ë ˆì´ì…˜"
    description: |
      cadCAD(complex adaptive dynamics Computer Aided Design)ëŠ”
      Mintê°€ ê°€ì¥ ì‹ ë¢°í•˜ëŠ” ì‹œë®¬ë ˆì´ì…˜ í”„ë ˆì„ì›Œí¬.
      í† í° ê²½ì œ ì‹œìŠ¤í…œì„ ìƒíƒœ ê³µê°„ ëª¨ë¸ë¡œ ì •ì˜í•˜ê³ 
      ë‹¤ì–‘í•œ ì •ì±…ì˜ ê²°ê³¼ë¥¼ ì‹œë®¬ë ˆì´ì…˜í•œë‹¤.
    use_cases:
      - "í† í° ê³µê¸‰ ëª¨ë¸ ì‹œë®¬ë ˆì´ì…˜"
      - "ì¸ì„¼í‹°ë¸Œ ë©”ì»¤ë‹ˆì¦˜ ê²€ì¦"
      - "ìŠ¤í…Œì´í‚¹/ì–¸ìŠ¤í…Œì´í‚¹ ë™ì  ë¶„ì„"
      - "ê±°ë²„ë„ŒìŠ¤ ê³µê²© ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸"
    config:
      simulation_timestep: "1 day"
      monte_carlo_runs: 100
      parameter_sweeps: true
    mint_note: |
      "cadCADì˜ ê°€ì¥ í° ì¥ì ì€ ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ë¥¼ 
      ë…ë¦½ì ìœ¼ë¡œ ì •ì˜í•  ìˆ˜ ìˆë‹¤ëŠ” ì . ë³µì¡í•œ ì‹œìŠ¤í…œì„ 
      ëª¨ë“ˆí™”í•´ì„œ ì´í•´í•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤."
  
  secondary:
    name: "Mesa"
    version: "2.1+"
    purpose: "ì—ì´ì „íŠ¸ í–‰ë™ ì‹œë®¬ë ˆì´ì…˜"
    description: |
      Python ê¸°ë°˜ ABM í”„ë ˆì„ì›Œí¬.
      ê°œë³„ ì—ì´ì „íŠ¸ì˜ í–‰ë™ ê·œì¹™ì„ ì •ì˜í•˜ê³ 
      ì „ì²´ ì‹œìŠ¤í…œì˜ ì°½ë°œì  í–‰ë™ì„ ê´€ì°°í•œë‹¤.
    use_cases:
      - "í† í° ë³´ìœ ì í–‰ë™ ëª¨ë¸ë§"
      - "ì‹œì¥ ë¯¸ì‹œêµ¬ì¡° ì‹œë®¬ë ˆì´ì…˜"
      - "ê±°ë²„ë„ŒìŠ¤ íˆ¬í‘œ íŒ¨í„´ ë¶„ì„"
      - "ê³ ë˜/ì†Œë§¤ íˆ¬ìì ìƒí˜¸ì‘ìš©"
    config:
      max_agents: 10000
      visualization: "browser-based"
      
  specialized:
    name: "TokenSPICE"
    version: "latest"
    purpose: "Ocean Protocolì˜ í† í° ì‹œë®¬ë ˆì´í„°"
    description: |
      ë°ì´í„° ê²½ì œ íŠ¹í™” ì‹œë®¬ë ˆì´í„°.
      EVM ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì™€ ì—°ë™ ê°€ëŠ¥.
    use_cases:
      - "ë°ì´í„° ë§ˆì¼“í”Œë ˆì´ìŠ¤ í† í° ì„¤ê³„"
      - "ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ë ˆë²¨ ì‹œë®¬ë ˆì´ì…˜"

# ================================================================
# 2. Gauntlet â€” ê²½ì œì  ë³´ì•ˆ ë¶„ì„
# ================================================================
gauntlet:
  name: "Gauntlet Network"
  type: "Economic Security Platform"
  purpose: "DeFi í”„ë¡œí† ì½œ ê²½ì œì  ë¦¬ìŠ¤í¬ ëª¨ë¸ë§"
  description: |
    Gauntletì€ ê¸ˆìœµê³µí•™ ìˆ˜ì¤€ì˜ ì‹œë®¬ë ˆì´ì…˜ì„ ì œê³µí•˜ëŠ” 
    í”„ë¡œí† ì½œ ë¦¬ìŠ¤í¬ ê´€ë¦¬ í”Œë«í¼.
    Mintê°€ Compound Labsì—ì„œ ì§ì ‘ í˜‘ì—…í•œ ê²½í—˜ì´ ìˆë‹¤.
  capabilities:
    - "ì‹œì¥ ë¦¬ìŠ¤í¬ ì‹œë®¬ë ˆì´ì…˜ (ê°€ê²© ì¶©ê²©, ìœ ë™ì„± ìœ„ê¸°)"
    - "í”„ë¡œí† ì½œ íŒŒë¼ë¯¸í„° ìµœì í™” (ë‹´ë³´ ë¹„ìœ¨, ì²­ì‚° ì„ê³„ì¹˜)"
    - "ê±°ë²„ë„ŒìŠ¤ ê³µê²© ë¹„ìš© ë¶„ì„"
    - "ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸ (ë¸”ë™ìŠ¤ì™„ ì´ë²¤íŠ¸)"
  integration:
    api: true
    custom_models: true
    report_format: "PDF + Interactive Dashboard"
  mint_note: |
    "Gauntletì€ 'ì´ íŒŒë¼ë¯¸í„°ë¥¼ ë°”ê¾¸ë©´ ì–¼ë§ˆì˜ ë¦¬ìŠ¤í¬ê°€ ìƒê¸°ëŠ”ê°€'ë¥¼
    ì •ëŸ‰ì ìœ¼ë¡œ ëŒ€ë‹µí•´ì£¼ëŠ” ìœ ì¼í•œ ë„êµ¬. Compoundì—ì„œ ì¼í•  ë•Œ
    ì‹¤ì œë¡œ ìˆ˜ì–µ ë‹¬ëŸ¬ì˜ ì˜ì‚¬ê²°ì •ì— ì‚¬ìš©í–ˆë‹¤."
  workflow:
    - step: "í”„ë¡œí† ì½œ ìƒíƒœ ìŠ¤ëƒ…ìƒ·"
    - step: "ì‹œë‚˜ë¦¬ì˜¤ ì •ì˜ (ì •ìƒ/ìŠ¤íŠ¸ë ˆìŠ¤/ë¸”ë™ìŠ¤ì™„)"
    - step: "Monte Carlo ì‹œë®¬ë ˆì´ì…˜ (10ë§Œ+ ì‹¤í–‰)"
    - step: "ë¦¬ìŠ¤í¬ ë©”íŠ¸ë¦­ ê³„ì‚° (VaR, CVaR, Expected Shortfall)"
    - step: "íŒŒë¼ë¯¸í„° ì¶”ì²œ ìƒì„±"
    - step: "ê±°ë²„ë„ŒìŠ¤ ì œì•ˆ ì´ˆì•ˆ ì‘ì„±"

# ================================================================
# 3. OpenZeppelin Governor â€” ì˜¨ì²´ì¸ ê±°ë²„ë„ŒìŠ¤
# ================================================================
openzeppelin_governor:
  name: "OpenZeppelin Governor"
  version: "5.0+"
  type: "Smart Contract Framework"
  purpose: "ì˜¨ì²´ì¸ ê±°ë²„ë„ŒìŠ¤ êµ¬í˜„ì˜ ê¸°ë³¸ ê³¨ê²©"
  description: |
    ì—…ê³„ í‘œì¤€ ê±°ë²„ë„ŒìŠ¤ í”„ë ˆì„ì›Œí¬.
    MintëŠ” ì´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í™•ì¥ ê¸°ëŠ¥ì„ ì¶”ê°€í•œë‹¤.
  modules_used:
    core:
      - "Governor.sol â€” í•µì‹¬ ê±°ë²„ë„ŒìŠ¤ ë¡œì§"
      - "GovernorSettings.sol â€” íˆ¬í‘œ ì§€ì—°/ê¸°ê°„/ì„ê³„ì¹˜"
      - "GovernorCountingSimple.sol â€” For/Against/Abstain